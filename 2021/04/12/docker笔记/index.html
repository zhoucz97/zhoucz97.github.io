<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Docker笔记 | 雪落山庄</title><meta name="keywords" content="Docker"><meta name="author" content="萧瑟,1059482037@qq.com"><meta name="copyright" content="萧瑟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="教程地址：datawhale组队学习之Docker教程  1. Docker概述 1.1 Docker为什么出现？ 项目带环境一块打包上线，docker就是做这个事情的。避免了不同机器配置环境所带来的麻烦。 打包项目带上环境（镜像机制）——docker仓库——下载镜像直接运行即可！ docker的思想来自于集装箱  **Docker核心思想：隔离，把所有东西打包装箱，每个箱子互相隔离。**再也不">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker笔记">
<meta property="og:url" content="https://zhoucz97.gitee.io/2021/04/12/docker%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="雪落山庄">
<meta property="og:description" content="教程地址：datawhale组队学习之Docker教程  1. Docker概述 1.1 Docker为什么出现？ 项目带环境一块打包上线，docker就是做这个事情的。避免了不同机器配置环境所带来的麻烦。 打包项目带上环境（镜像机制）——docker仓库——下载镜像直接运行即可！ docker的思想来自于集装箱  **Docker核心思想：隔离，把所有东西打包装箱，每个箱子互相隔离。**再也不">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhoucz97.gitee.io/image-bed/WallpaperCollection/705446.jpg">
<meta property="article:published_time" content="2021-04-11T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-14T16:00:00.000Z">
<meta property="article:author" content="萧瑟">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhoucz97.gitee.io/image-bed/WallpaperCollection/705446.jpg"><link rel="shortcut icon" href="https://zhoucz97.gitee.io/image-bed/others/favicon.png"><link rel="canonical" href="https://zhoucz97.gitee.io/2021/04/12/docker%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: 萧瑟","link":"链接: ","source":"来源: 雪落山庄","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-15 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="雪落山庄" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://zhoucz97.gitee.io/image-bed/others/touxiang.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://zhoucz97.gitee.io/image-bed/WallpaperCollection/705446.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">雪落山庄</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Docker笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-11T16:00:00.000Z" title="发表于 2021-04-12 00:00:00">2021-04-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-14T16:00:00.000Z" title="更新于 2021-04-15 00:00:00">2021-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>教程地址：<a target="_blank" rel="noopener" href="https://github.com/datawhalechina/team-learning-program/tree/master/Docker">datawhale组队学习之Docker教程</a></p>
</blockquote>
<h1>1. Docker概述</h1>
<h2 id="1-1-Docker为什么出现？">1.1 Docker为什么出现？</h2>
<p>项目带环境一块打包上线，docker就是做这个事情的。避免了不同机器配置环境所带来的麻烦。</p>
<p>打包项目带上环境（镜像机制）——docker仓库——下载镜像直接运行即可！</p>
<p>docker的思想来自于集装箱</p>
<p><img src="https://i.loli.net/2021/03/31/5azISJnevGqs8Ru.png" alt=""></p>
<p>**Docker核心思想：隔离，把所有东西打包装箱，每个箱子互相隔离。**再也不用担心环境的问题。</p>
<p>例如一个集装箱装水果，另一个装生化武器，两个互不干扰，并且可以在同一机器上运行。</p>
<p>Docker还通过隔离机制，将服务器性能利用到极致。</p>
<h2 id="1-2-Docker历史">1.2 Docker历史</h2>
<ul>
<li><strong>Docker</strong> 最初是 <code>dotCloud</code> 公司（2010年创立）创始人 <a target="_blank" rel="noopener" href="https://github.com/shykes">Solomon Hykes (opens new window)</a>在法国期间发起的一个公司内部项目，它是基于 <code>dotCloud</code> 公司多年云服务技术的一次革新，并于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Docker_(software)">2013 年 3 月以 Apache 2.0 授权协议开源 </a>，主要项目代码在 <a target="_blank" rel="noopener" href="https://github.com/moby/moby">GitHub </a>上进行维护。<code>Docker</code> 项目后来还加入了 Linux 基金会，并成立推动 <a target="_blank" rel="noopener" href="https://opencontainers.org/">开放容器联盟（OCI）</a>。</li>
<li>Docker每个月都会更新一个版本。</li>
<li>2014年4月9日，Docker1.0发布！</li>
</ul>
<p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a target="_blank" rel="noopener" href="https://golang.google.cn/">Go 语言</a>进行开发实现，基于 <code>Linux</code> 内核的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Cgroups">cgroup </a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace </a>，以及 <a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS </a>类的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_mount">Union FS </a>等技术，对进程进行封装隔离，属于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术 </a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为<strong>容器</strong>。</p>
<p>Docker为什么这么火？轻巧。容器技术出来之前，大家都用虚拟机技术，虚拟机十分笨重。</p>
<p>虚拟机和Docker容器都是虚拟化技术。</p>
<p>VM：Linux centos原生镜像（一个电脑！）   隔离，需要开启多个虚拟机；   几个G</p>
<p>Docker：隔离， 镜像（最核心的环境，很小）  运行镜像就可以了。    几个M</p>
<p>Docker基于Go语言开发，Docker的文档超级详细。</p>
<blockquote>
<p>仓库地址：<a target="_blank" rel="noopener" href="http://hub.docker.com">hub.docker.com</a></p>
<p>文档地址：<a target="_blank" rel="noopener" href="http://docs.docker.com">docs.docker.com</a></p>
</blockquote>
<h2 id="1-3-Docker与虚拟机">1.3 Docker与虚拟机</h2>
<p>虚拟机：</p>
<p><img src="https://i.loli.net/2021/03/31/JvOL12FIH9DBARC.png" alt=""></p>
<p>Docker容器：</p>
<p><img src="https://i.loli.net/2021/03/31/IegG3OoF5kQz164.png" alt=""></p>
<ul>
<li><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</li>
<li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</li>
<li>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。每个容器间互相隔离，每个容器内都有一个属于自己的文件系统。</li>
</ul>
<p><strong>Docker为什么比虚拟机快</strong>？</p>
<ol>
<li>Docker有比虚拟机更少的抽象层</li>
<li>Docker利用的是宿主机的内核，VM需要GuestOS</li>
</ol>
<p><img src="https://i.loli.net/2021/03/31/HNv3h7coQbYfAlz.png" alt=""></p>
<p>所以说新建一个容器时，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导性的操作。虚拟机是加载GuestOS，分钟级别的，很慢。而Docker是利用宿主机的操作系统，省略了这个复杂的过程，是秒级的。</p>
<p><img src="https://i.loli.net/2021/03/31/hETeanUPv1pWylO.png" alt=""></p>
<p><strong>DevOps(开发，运维)</strong>：</p>
<ol>
<li>
<p>更快速的交付和部署。</p>
<p>传统：一堆帮助文档，安装程序；</p>
<p>Docker：打包镜像，发布测试，一键运行。</p>
</li>
<li>
<p>更便捷的升级和扩缩容</p>
<p>使用 Docker之后，部署应用就像搭积木一样。</p>
<p>项目打包为一个镜像。</p>
</li>
<li>
<p>更简单的系统运维</p>
<p>在容器化之后，开发和测试环境高度一致。不会再出现“你的电脑上没问题，我的电脑上出问题了”这种问题。</p>
</li>
<li>
<p>更高效的计算资源利用</p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例。服务器的性能可以被压榨到极致。</p>
</li>
</ol>
<h1>2. Docker安装</h1>
<h2 id="2-1-Docker的基本组成">2.1 Docker的基本组成</h2>
<p><img src="https://i.loli.net/2021/03/31/r7SzGVEBdtm51vi.png" alt="Docker架构图"></p>
<p><strong>镜像（Image）</strong>：Docker镜像就像是一个模板，可以通过模板来创建容器服务，</p>
<p>例如：Tomcat镜像——&gt;run——&gt;tomcat01容器（提供服务器），通过这个镜像可以创建多个容器，最终服务运行或者项目运行就是在容器中的。</p>
<p><strong>容器（Container）</strong>：</p>
<p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p>
<p>基本命令：启动、停止、删除。</p>
<p><strong>仓库（Repository）</strong>：</p>
<p>存放镜像的地方。分为公有仓库和私有仓库。</p>
<h3 id="2-1-1-Docker镜像">2.1.1 Docker镜像</h3>
<p>操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p>
<h4 id="分层存储">分层存储</h4>
<p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，体积庞大，因此在 Docker 设计时，就充分利用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a>的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。<em>因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</em></p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="2-1-2-Docker容器">2.1.2 Docker容器</h3>
<p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p><strong>容器的实质是进程</strong>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间 </a>。因此容器可以拥有自己的 <code>root</code> 文件系统、网络配置、进程空间，甚至用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p>
<p>镜像使用的是分层存储，容器也是如此。<strong>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层</strong>，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/data_management/volume.html">数据卷（Volume）</a>、或者 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/data_management/bind-mounts.html">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="2-1-3-Docker仓库">2.1.3 Docker仓库</h3>
<p>集中的存储、分发镜像的服务。一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。与Github仓库类似，分为公开仓库和私有仓库。</p>
<h2 id="2-2-安装Docker">2.2 安装Docker</h2>
<p>需要一台Linux服务器。狂神使用的是阿里云的centos7。</p>
<p>系统版本：</p>
<p><img src="https://i.loli.net/2021/03/31/5rbDUGYLmsV8KQI.png" alt=""></p>
<p>官网centos系统的Docker安装教程：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 卸载旧的docker版本</span></span><br><span class="line"> sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 安装需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 改镜像仓库，改成阿里云的</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo  # 默认国外，太慢，不用</span><br><span class="line">	</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">	http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  # 阿里云</span><br><span class="line">	</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 安装Docker相关的依赖    docker-ce社区版   -ee企业版</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 启动docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 查看是否安装成功</span></span><br><span class="line">docker version</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 测试hello world</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/31/Ajq9Hb2SkGFchfg.png" alt=""></p>
<p>运行官方demo  hello-world，没有发现该镜像，于是去官网pull一个hello-world镜像，下载成功后运行该镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 8. 查看一下下载的hello-world镜像</span></span><br><span class="line">docker images  # 查看所有镜像</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> extra：卸载docker</span></span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> /var/lin/docker  docker的默认工作路径</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-阿里云镜像加速">2.3 阿里云镜像加速</h2>
<ol>
<li>阿里云的容器镜像服务</li>
<li>找到镜像工具-镜像加速器</li>
</ol>
<p><img src="https://i.loli.net/2021/03/31/jJd5MKy4ba7ir8W.png" alt=""></p>
<ol start="3">
<li>配置使用</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://ejhhjy6f.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="2-4-回顾hello-world流程">2.4 回顾hello-world流程</h2>
<p><img src="https://i.loli.net/2021/03/31/M8jQwN4SVRIp3Dl.png" alt=""></p>
<h2 id="2-5-底层原理">2.5 底层原理</h2>
<p>Docker是怎么工作的？</p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问。</p>
<p>DockerServer接收到Docker-Client的指令，就会执行这个命令。</p>
<p><img src="https://i.loli.net/2021/03/31/Ks3f68u5PIcUb17.png" alt=""></p>
<p>学完命令再看这段理论，会很清晰。</p>
<h1>3. Docker常用命令</h1>
<h2 id="3-1-帮助命令">3.1 帮助命令</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version		# 版本</span><br><span class="line">docker info			# 详细信息</span><br><span class="line">docker 命令 --help		# 帮助命令</span><br></pre></td></tr></table></figure>
<p>帮助文档地址（可查找所有docker命令）：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline">https://docs.docker.com/engine/reference/commandline</a></p>
<h2 id="3-2-镜像命令">3.2 镜像命令</h2>
<h3 id="3-2-1-获取-下载镜像">3.2.1 获取/下载镜像</h3>
<p>完整命令：</p>
<p><code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></p>
<blockquote>
<p>[Docker Registry 地址[:端口号]/] 默认是Docker Hub(<a target="_blank" rel="noopener" href="http://docker.io">docker.io</a>)</p>
<p>仓库名格式是&lt;用户名&gt;/&lt;软件名&gt;，用户名默认是library</p>
<p>比如说最新版本的mysql的完整命令是：<a target="_blank" rel="noopener" href="http://docker.io/library/mysql:latest">docker.io/library/mysql:latest</a></p>
<p>docker pull mysql == docker pull <a target="_blank" rel="noopener" href="http://docker.io/library/mysql:latest">docker.io/library/mysql:latest</a></p>
</blockquote>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名[:tag]  # 下载版本为tag的镜像，不加tag下载最新版</span><br><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker pull mysql</span><br><span class="line">Using default tag: latest   # 不写tag，默认最新版</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">a076a628af6f: Pull complete   # 分层下载，docker image 的核心   联合文件系统</span><br><span class="line">f6c208f3f991: Pull complete</span><br><span class="line">88a9455a9165: Pull complete</span><br><span class="line">406c9b8427c6: Pull complete</span><br><span class="line">7c88599c0b25: Pull complete</span><br><span class="line">25b5c6debdaf: Pull complete</span><br><span class="line">43a5816f1617: Pull complete</span><br><span class="line">1a8c919e89bf: Pull complete</span><br><span class="line">9f3cf4bd1a07: Pull complete</span><br><span class="line">80539cea118d: Pull complete</span><br><span class="line">201b3cad54ce: Pull complete</span><br><span class="line">944ba37e1c06: Pull complete</span><br><span class="line">Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c  # 签名防伪标志</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest  # 真实地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载指定版本</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">a076a628af6f: Already exists  # 前面已经下载过，就不用再下载了，分层共用的好处</span><br><span class="line">f6c208f3f991: Already exists</span><br><span class="line">88a9455a9165: Already exists</span><br><span class="line">406c9b8427c6: Already exists</span><br><span class="line">7c88599c0b25: Already exists</span><br><span class="line">25b5c6debdaf: Already exists</span><br><span class="line">43a5816f1617: Already exists</span><br><span class="line">1831ac1245f4: Pull complete</span><br><span class="line">37677b8c1f79: Pull complete</span><br><span class="line">27e4ac3b0f6e: Pull complete</span><br><span class="line">7227baa8c445: Pull complete</span><br><span class="line">Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-列出镜像">3.2.2 列出镜像</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker images [options]  # 查看所有本地主机的镜像</span><br><span class="line">docker image ls          # 查看所有本地主机的镜像</span><br><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">hello-world   latest    d1165f221234   3 weeks ago   13.3kB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解释</span></span><br><span class="line">REPOSITORY  镜像的仓库源（名字）</span><br><span class="line">TAG			镜像标签</span><br><span class="line">IMAGE ID    id</span><br><span class="line">CREATED     镜像创建时间</span><br><span class="line">SIZE        镜像大小</span><br><span class="line"></span><br><span class="line">ID是镜像的唯一标识，一个镜像可对应多个标签。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> options可选项</span></span><br><span class="line">-a, -all	# 列出所有镜像(包括隐藏镜像)</span><br><span class="line">-q, -quiet  # 只显示镜像id</span><br><span class="line">-aq         # 显示所有镜像的id</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-删除镜像">3.2.3 删除镜像</h3>
<p><code>docker image rm [options] &lt;IMAGE1&gt; [&lt;IMAGE2&gt;...]</code></p>
<p><code>docker rmi [options] &lt;IMAGE1&gt; [&lt;IMAGE2&gt; ...]</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-f  # 强制移除镜像</span><br><span class="line"></span><br><span class="line">docker rmi -f 镜像id   # 删除指定镜像</span><br><span class="line">docker rmi -f 镜像id1 镜像id2 镜像id3  # 删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -aq)  # 递归删除所有镜像（Linux的骚操作）</span><br><span class="line">docker rmi -f $(docker image ls -q redis)  # 删除所有仓库名为redis的镜像</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用镜像ID删除镜像，可以只取前几位，只要能与其他镜像区分开就可以</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image rm 501  <span class="comment"># 删除redis</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用镜像名删除镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker iamge rm centos</span></span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用镜像摘要删除镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls --digests</span></span><br><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span></span><br><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure>
<p><strong>Untagged</strong>和<strong>Deleted</strong></p>
<p>因为每个镜像都有一个TAG，而一个TAG可能对应多个镜像，我们的删除命令实际上是要求<strong>删除某个标签的镜像</strong>，所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当镜像的所有标签都被取消，该镜像很可能失去了存在的意义，因此触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p>
<p>还有就是如果有容器正在依赖该镜像，那么该镜像也不可删除。</p>
<h3 id="3-2-4-搜索镜像">3.2.4 搜索镜像</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker search [options]  # 在docker hub上搜索镜像</span><br><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10680     [OK]</span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   4011      [OK]</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项，通过搜索来过滤</span></span><br><span class="line">--filter=STARS=3000  # 搜stars为3000以上的</span><br></pre></td></tr></table></figure>
<h3 id="3-2-5-Dockerfile构建镜像">3.2.5 Dockerfile构建镜像</h3>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，<strong>每一条指令构建一层</strong>，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>空白目录建立文本文件，并命名为<code>Dockerfile</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir mynginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> mynginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch Dockerfile</span></span><br></pre></td></tr></table></figure>
<p>内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<h4 id="FROM指定基础镜像">FROM指定基础镜像</h4>
<p>构建镜像必然是以一个镜像为基础，在其上定制。FROM的作用就是指定基础镜像。所以在<code>Dockerfile</code>中FROM是必备指令，且是第一条指令。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果你 <code>scratch</code> 为基础镜像的话，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。</p>
<h4 id="RUN执行命令">RUN执行命令</h4>
<p>RUN是用来执行命令行命令的。格式有两种：</p>
<ul>
<li>shell格式：<code>RUN &lt;命令&gt;</code>，就像我们刚才使用的那样。</li>
<li>exec格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li>
</ul>
<p>比如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>
<p>Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>
<p>正确写法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN set -x; buildDeps=&#x27;gcc libc6-dev make wget&#x27; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>牢记：这不是在写shell脚本，而是在定义每一层该如何构建。</p>
<p>此外，别忘了最后添加清理工作的命令，删除为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。</p>
</blockquote>
<h4 id="构建镜像">构建镜像</h4>
<p>我们继续构建nginx镜像</p>
<p>进入<code>Dockerfile</code>文件所在的mynginx目录，执行以下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里我们指定了镜像的名称 -t nginx:v3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后的 . 表示当前目录</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ mynginx]# docker build -t nginx:v3 .   </span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> f6d0b4767a6c</span></span><br><span class="line">Step 2/2 : RUN echo &#x27;&lt;h1&gt;Hello, Dokcer!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> a0b6b23016fd</span></span><br><span class="line">Removing intermediate container a0b6b23016fd</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> bad85166b231</span></span><br><span class="line">Successfully built bad85166b231</span><br><span class="line">Successfully tagged nginx:v3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个就是我们构建的镜像</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ mynginx]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        v3        bad85166b231   2 minutes ago   133MB</span><br><span class="line">tomcat       9.0       040bdb29ab37   2 months ago    649MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>镜像构建</strong>命令：</p>
<p><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></p>
<h4 id="镜像构建上下文（Context）">镜像构建上下文（Context）</h4>
<p><code>docker build</code>命令最后的<code>.</code>表示的是当前目录，而不是<code>Dockerfile</code>文件所在路径。准确的说，<code>.</code>是在指定<strong>上下文路径</strong>。</p>
<blockquote>
<p><code>docker build</code>工作原理如下：Docker在运行时分为Docker引擎（服务端守护进程）和客户端工具。Docker引擎提供了一组REST API，如docker命令这样的客户端工具，通过这组API与引擎交互。因此，表面看我们是在本机执行docker各种功能，实际上是远程调用Docker引擎来完成的。</p>
</blockquote>
<p>那么构建镜像时，远程服务端怎么获得本地文件呢？<strong>答案就是通过上下文文件，构建时用户指定上下文路径，<code>docker build</code>会将该路径所有文件打包，上传给docker引擎。</strong></p>
<h2 id="3-3-容器命令">3.3 容器命令</h2>
<p>说明：有了镜像才能创建容器，下载一个centos镜像来测试学习</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker run</td>
<td>新建容器</td>
</tr>
<tr>
<td>docker ps</td>
<td>列出容器</td>
</tr>
<tr>
<td>exit</td>
<td>退出容器</td>
</tr>
<tr>
<td>docker rm</td>
<td>删除容器</td>
</tr>
<tr>
<td>docker start 容器id</td>
<td>启动容器</td>
</tr>
<tr>
<td>docker restart 容器id</td>
<td>重启容器</td>
</tr>
<tr>
<td>docker stop 容器id</td>
<td>停止当前运行容器</td>
</tr>
<tr>
<td>docker kill 容器id</td>
<td>强制停止容器</td>
</tr>
</tbody>
</table>
<h3 id="3-3-1-新建并启动容器">3.3.1 新建并启动容器</h3>
<p>当执行<code>docker run</code>来创建容器时，Docker在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否有该镜像，不存在就从registry下载；</li>
<li>利用镜像创建并启动一个容器；</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层；</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；</li>
<li>从地址池配置一个 ip 地址给容器；</li>
<li>执行用户指定的应用程序；</li>
<li>执行完毕后容器被终止。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">docker run [options] imageName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name Name    # 容器名字，用来区分容器</span><br><span class="line">-d               # 后台方式运行</span><br><span class="line">-it			     # 交互方式运行，进入容器查看内容</span><br><span class="line">-t               # Dockers分配一个伪终端并绑定到容器的标准输入上</span><br><span class="line">-i               # 让容器的标准输入保持打开</span><br><span class="line">-p               # 指定容器端口  -p 8080:8080</span><br><span class="line">	-p ip:主机端口:容器端口</span><br><span class="line">	-p 主机端口:容器端口   （常用）</span><br><span class="line">	-p 容器端口</span><br><span class="line">	容器端口</span><br><span class="line">-P               # 随机指定端口</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动镜像centos并进入容器</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@5dfc69f1db45 /]#</span><br><span class="line"></span><br><span class="line">[root@5dfc69f1db45 /]# ls  # 查看容器内的centos（基础版本，很多命令都不完善）</span><br><span class="line">bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line"></span><br><span class="line">[root@5dfc69f1db45 /]# exit   # 从容器中退出</span><br><span class="line">exit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关，只要命令不结束，容器也就不会退出。比如命令中如果while语句是死循环，不让bash退出，那么容器就不会退出。</p>
</blockquote>
<h3 id="3-3-2-启动已终止容器">3.3.2 启动已终止容器</h3>
<p>利用<code>docker container start 容器id</code>，直接将一个已经终止（exited）的容器启动运行。</p>
<h3 id="3-3-3-停止容器">3.3.3 停止容器</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器id           # 停止当前运行的容器</span><br><span class="line">docker kill 容器id           # 强制停止当前容器</span><br></pre></td></tr></table></figure>
<h3 id="3-3-4-重启容器">3.3.4 重启容器</h3>
<p><code>docker start 容器id</code>会保留容器的第一次启动时的所有参数。</p>
<p><code>docker restart 容器id</code>作用是依次执行<code>docker stop</code>和<code>docker start</code>。</p>
<p>容器可能会因某些错误意外停止运行。对于服务类容器，通常希望它能够自动重启。启动容器时设置–restart就可以达到效果。–restart=always意味着无论容器因何种原因退出（包括正常退出），都立即重启；</p>
<h3 id="3-3-5-列出运行容器">3.3.5 列出运行容器</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker ps [options]  # 默认列出当前正在运行的容器</span><br><span class="line">docker container ls [options]  # 默认列出当前正在运行的容器</span><br><span class="line">-a     # 列出当前正在运行和曾经运行过的容器</span><br><span class="line">-n=数量   # 显示最近创建的几个容器</span><br><span class="line">-q      # 只显示容器id</span><br><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker ps  # 查看当前正在运行的容器</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker ps -a  # 查看曾经运行过的容器</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                            PORTS     NAMES</span><br><span class="line">5dfc69f1db45   centos         &quot;/bin/bash&quot;   4 minutes ago   Exited (130) About a minute ago             admiring_euclid</span><br><span class="line">0f243e550191   d1165f221234   &quot;/hello&quot;      15 hours ago    Exited (0) 15 hours ago                     crazy_napier</span><br></pre></td></tr></table></figure>
<h3 id="3-3-6-进入容器">3.3.6 进入容器</h3>
<h4 id="attach命令"><code>attach</code>命令</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker run -dit centos</span><br><span class="line">b2a51a873e9389bc5cee88e052ddeeea555f887b1fb5186a610eaa1b7e284c22</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker container ls</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES</span><br><span class="line">b2a51a873e93   centos    &quot;/bin/bash&quot;   11 seconds ago   Up 9 seconds             relaxed_sutherland</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker attach b2a</span><br><span class="line">[root@b2a51a873e93 /]#</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果从这个stdin中exit回到host端，容器会停止。</p>
</blockquote>
<h4 id="exec命令"><code>exec</code>命令</h4>
<p><code>docker exec</code>后可以跟多个参数。只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker run -dit centos</span><br><span class="line">8b1861aba38b41b463c68c5ee021327e41513a2623dad3cb797481d67905e9c3</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker container ls</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">8b1861aba38b   centos    &quot;/bin/bash&quot;   4 seconds ago   Up 3 seconds             infallible_neumann</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker exec -i 8b18 bash</span><br><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker exec -it 8b18 bash</span><br><span class="line">[root@8b1861aba38b /]#</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从这个 stdin 中 exit回到host端，不会导致容器的停止。</p>
</blockquote>
<p><strong>attach和exec的区别</strong>：（1）attach直接进入容器启动命令的终端，不会启动新的进程； （2）exec则是在容器中打开新的终端，并且可以启动新的进程； （3）如果想直接在终端中查看命令的输出，用attach，其他情况使用exec；</p>
<h3 id="3-3-7-退出容器">3.3.7 退出容器</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit  # 容器停止并退出</span><br><span class="line">Ctrl + P + Q  # 容器不停止并退出</span><br></pre></td></tr></table></figure>
<h3 id="3-3-8-删除容器">3.3.8 删除容器</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id                  # 删除指定容器（不能删除正在运行的容器，除非用rm -f）</span><br><span class="line">docker rm -f $(docker ps -aq)    # 删除所有容器</span><br><span class="line">docker ps -a -q|xargs docker rm  # 删除所有容器</span><br><span class="line">docker container prune           # 删除所有处于终止状态的容器</span><br><span class="line">docker rm -v $(docker ps -aq -f status=exited)  # 批量删除所有已经退出的容器</span><br></pre></td></tr></table></figure>
<h3 id="3-3-9-暂停容器">3.3.9 暂停容器</h3>
<p><code>docker pause 容器id</code></p>
<h3 id="3-3-10-导出容器">3.3.10 导出容器</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker container ls -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS                        PORTS     NAMES</span><br><span class="line">8b1861aba38b   centos    &quot;/bin/bash&quot;         6 minutes ago    Up 6 minutes                            infallible_neumann</span><br><span class="line">b2a51a873e93   centos    &quot;/bin/bash&quot;         8 minutes ago    Exited (130) 6 minutes ago              relaxed_sutherland</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker export 8b18 &gt; /mnt/zhoucz/centos.bar</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-3-11-导入容器快照">3.3.11 导入容器快照</h3>
<p>从容器快照文件中导入为镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ /]# cat /mnt/zhoucz/centos.bar | docker import - test/centos:v9.999</span><br><span class="line">sha256:25a6a65ad0f4e9b29ec12d85dcec35a98a985152638c7086b0058170b61b8b3c</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ /]# docker image ls</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">test/centos   v9.999    25a6a65ad0f4   6 seconds ago   209MB</span><br><span class="line">nginx         v3        bad85166b231   2 days ago      133MB</span><br><span class="line">tomcat        9.0       040bdb29ab37   3 months ago    649MB</span><br><span class="line">tomcat        latest    040bdb29ab37   3 months ago    649MB</span><br><span class="line">python        3.6       6b0219e0ed75   3 months ago    874MB</span><br><span class="line">nginx         latest    f6d0b4767a6c   3 months ago    133MB</span><br><span class="line">centos        latest    300e315adb2f   4 months ago    209MB</span><br></pre></td></tr></table></figure>
<p>也可通过指定URL或某个目录来导入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker import http://example.com/exampleimage.tgz example/imagerepo</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
</blockquote>
<h2 id="3-4-常用其他命令">3.4 常用其他命令</h2>
<p>后台启动容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动容器：docker run -d 镜像名</span></span><br><span class="line">docker run -d centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 问题：使用docker ps， 发现centos停止了</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见的坑：docker使用后台运行，就必须要有一个前台进程。docker反向没有应用，就会自动停止</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx，  容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></span><br></pre></td></tr></table></figure>
<p>查看日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写一段shell脚本，不停地打印zcz</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker run -d centos /bin/sh -c &quot;while true;do echo zcz;sleep 1;done&quot;</span><br><span class="line">e597be3ca6febe4246bf7c57d9fd9d2e633b8c643453aa1d9cd8e35d4b6d770a</span><br><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">e597be3ca6fe   centos    &quot;/bin/sh -c &#x27;while t…&quot;   33 seconds ago   Up 32 seconds             vibrant_dijkstra</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示日志</span></span><br><span class="line">-tf          # 显示日志</span><br><span class="line">--tail num   # 要显示的日志条数</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker logs -f -t --tail 5 e597be3ca6fe  # 显示指定行数的日志</span><br><span class="line">2021-04-02T05:10:28.332572202Z zcz</span><br><span class="line">2021-04-02T05:10:29.335579873Z zcz</span><br><span class="line">2021-04-02T05:10:30.338541980Z zcz</span><br><span class="line">2021-04-02T05:10:31.341479563Z zcz</span><br><span class="line">2021-04-02T05:10:32.344343431Z zcz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看容器中的进程信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id</span><br><span class="line"></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker top e597be3ca6fe</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                30451               30431               0                   13:08               ?                   00:00:00            /bin/sh -c while true;do echo zcz;sleep 1;done</span><br><span class="line">root                31111               30451               0                   13:13               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看容器的元数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id    # 查看容器所有信息，很多</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker inspect e597be3ca6fe</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;e597be3ca6febe4246bf7c57d9fd9d2e633b8c643453aa1d9cd8e35d4b6d770a&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-04-02T05:08:13.56414271Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true;do echo zcz;sleep 1;done&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 30451,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2021-04-02T05:08:13.966405181Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/e597be3ca6febe4246bf7c57d9fd9d2e633b8c643453aa1d9cd8e35d4b6d770a/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/e597be3ca6febe4246bf7c57d9fd9d2e633b8c643453aa1d9cd8e35d4b6d770a/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/e597be3ca6febe4246bf7c57d9fd9d2e633b8c643453aa1d9cd8e35d4b6d770a/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/e597be3ca6febe4246bf7c57d9fd9d2e633b8c643453aa1d9cd8e35d4b6d770a/e597be3ca6febe4246bf7c57d9fd9d2e633b8c643453aa1d9cd8e35d4b6d770a-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/vibrant_dijkstra&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/939dc725bed830236316fea321e04af162744f44072827372669df9ff2c2f1b2-init/diff:/var/lib/docker/overlay2/12942808314c9217ac8aedd99858712a95279513321ac740530096373f482e4b/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/939dc725bed830236316fea321e04af162744f44072827372669df9ff2c2f1b2/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/939dc725bed830236316fea321e04af162744f44072827372669df9ff2c2f1b2/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/939dc725bed830236316fea321e04af162744f44072827372669df9ff2c2f1b2/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;e597be3ca6fe&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true;do echo zcz;sleep 1;done&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20201204&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;e73698db27cfa3b73ff76cf34aadef82912668506c4bc79852c2c4c3e75937ac&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/e73698db27cf&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;727544846d92aa83705be3a7e0dfaf27381411eb9019e1d1b090053d96e51864&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.18.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.18.0.3&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;16525c1ecff55e1fd07c6cd7dc6e3b9d1fc29d46ec296d16db3dd0d96f3a3b3f&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;727544846d92aa83705be3a7e0dfaf27381411eb9019e1d1b090053d96e51864&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.18.0.3&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进入当前正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行，需要进入容器，修改一些配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">e597be3ca6fe   centos    &quot;/bin/sh -c &#x27;while t…&quot;   10 minutes ago   Up 10 minutes             vibrant_dijkstra</span><br><span class="line">fd178f773e6d   centos    &quot;/bin/bash&quot;              23 minutes ago   Up 23 minutes             mystifying_poincare</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker exec -it e597be3ca6fe /bin/bash</span><br><span class="line">[root@e597be3ca6fe /]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 05:08 ?        00:00:00 /bin/sh -c while true;do echo zcz;sleep 1;done</span><br><span class="line">root       663     0  0 05:19 pts/0    00:00:00 /bin/bash</span><br><span class="line">root       681     1  0 05:19 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line">root       682   663  0 05:19 pts/0    00:00:00 ps -ef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试   正在执行当前的代码（这里写的是死循环，出不来了，只能断掉了服务器）</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker attach e597be3ca6fe</span><br><span class="line">zcz</span><br><span class="line">zcz</span><br><span class="line">zcz</span><br><span class="line">zcz</span><br><span class="line">zcz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span>   <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dockerattach  <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从容器内拷贝文件到主机上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试，在docker内的centos容器中新建一个文件，并拷贝到主机的home目录下</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ home]# docker attach 2760718a4b8a   # 进入容器</span><br><span class="line">[root@2760718a4b8a /]# cd /home</span><br><span class="line">[root@2760718a4b8a home]# touch test.docker  # 新建文件</span><br><span class="line">[root@2760718a4b8a home]# exit   # 退出容器</span><br><span class="line">exit</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ home]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS                      PORTS     NAMES</span><br><span class="line">2760718a4b8a   centos    &quot;/bin/bash&quot;   About a minute ago   Exited (0) 10 seconds ago             focused_almeida</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ home]# docker cp 2760718a4b8a:/home/test.docker /home  # 拷贝</span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ home]# ls</span><br><span class="line">test.docker  www  zcz.docker  zhoucz  zzz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝是手动的，未来我们使用-v卷技术来自动实现</span></span><br></pre></td></tr></table></figure>
<h2 id="3-5-小结">3.5 小结</h2>
<p><img src="https://i.loli.net/2021/04/15/VSN4hzO9tyraXue.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ home]# docker --help</span><br><span class="line"></span><br><span class="line">Usage:  docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime for containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --config string      Location of client config files (default &quot;/root/.docker&quot;)</span><br><span class="line">  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with &quot;docker</span><br><span class="line">                           context use&quot;)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line">  -H, --host list          Daemon socket(s) to connect to</span><br><span class="line">  -l, --log-level string   Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;)</span><br><span class="line">      --tls                Use TLS; implied by --tlsverify</span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default &quot;/root/.docker/ca.pem&quot;)</span><br><span class="line">      --tlscert string     Path to TLS certificate file (default &quot;/root/.docker/cert.pem&quot;)</span><br><span class="line">      --tlskey string      Path to TLS key file (default &quot;/root/.docker/key.pem&quot;)</span><br><span class="line">      --tlsverify          Use TLS and verify the remote</span><br><span class="line">  -v, --version            Print version information and quit</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  app*        Docker App (Docker Inc., v0.9.1-beta3)</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  buildx*     Build with BuildKit (Docker Inc., v0.5.1-docker)</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  image       Manage images</span><br><span class="line">  manifest    Manage Docker image manifests and manifest lists</span><br><span class="line">  network     Manage networks</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container&#x27;s changes</span><br><span class="line">  cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes to files or directories on a container&#x27;s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  exec        Run a command in a running container</span><br><span class="line">  export      Export a container&#x27;s filesystem as a tar archive</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  images      List images</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  info        Display system-wide information</span><br><span class="line">  inspect     Return low-level information on Docker objects</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  login       Log in to a Docker registry</span><br><span class="line">  logout      Log out from a Docker registry</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  ps          List containers</span><br><span class="line">  pull        Pull an image or a repository from a registry</span><br><span class="line">  push        Push an image or a repository to a registry</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  rmi         Remove one or more images</span><br><span class="line">  run         Run a command in a new container</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  search      Search the Docker Hub for images</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br><span class="line">Run &#x27;docker COMMAND --help&#x27; for more information on a command.</span><br><span class="line"></span><br><span class="line">To get more help with docker, check out our guides at https://docs.docker.com/go/guides/</span><br></pre></td></tr></table></figure>
<h1>4. Docker数据管理</h1>
<h2 id="4-1-数据卷">4.1 数据卷</h2>
<p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS (UNIX File System) ，可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>docker的镜像是由多个只读的文件系统叠加在一起形成的。当我们在我启动一个容器的时候，docker会加载这些只读层并在这些只读层的上面(栈顶)增加一个读写层。这时如果修改正在运行的容器中已有的文件，那么这个文件将会从只读层复制到读写层。该文件的只读版本还在，只是被上面读写层的该文件的副本隐藏。当删除docker,或者重新启动时，之前的更改将会消失。在Docker中，只读层及在顶部的读写层的组合被称为Union File System（联合文件系统）。</p>
<p>为了很好的实现数据保存和数据共享，Docker提出了Volume这个概念，简单的说就是绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。又被称作数据卷。</p>
</blockquote>
<h3 id="4-1-1-创建数据卷">4.1.1 创建数据卷</h3>
<p><code>docker volume create xxx</code></p>
<h3 id="4-1-2-查看数据卷">4.1.2 查看数据卷</h3>
<p><strong>查看所有数据卷</strong></p>
<p><code>docker volume ls</code></p>
<p><strong>查看指定数据卷</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ share]# docker volume inspect datawhale</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2021-04-16T14:12:15+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/datawhale/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;datawhale&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>查看数据卷的具体信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ share]# docker inspect web</span><br></pre></td></tr></table></figure>
<p>数据卷信息在<code>mounts</code>中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;datawhale&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/datawhale/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-启动一个挂载数据卷的容器">4.1.3 启动一个挂载数据卷的容器</h3>
<p><code>--mount</code>标记可以将数据卷挂载到容器中。一次<code>docker run</code>中可以挂载多个数据卷。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个数据卷到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ share]# docker run -d -P --name test --mount source=datawhale,target=/usr/share/nginx/html nginx</span><br><span class="line">66a8f9b7aa1e47eb5cd08827e607ba319d535cfeeba59086beb924d6ba2ddd6b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–mount参数说明：</p>
<p>​	source:数据卷</p>
<p>​    target:<strong>容器内部</strong>文件系统挂载点</p>
<p>注：可以不提前创建好数据卷，直接在运行容器的时候mount 这时如果不存在指定的数据卷，docker会自动创建，自动生成。</p>
</blockquote>
<h3 id="4-1-4-删除数据卷">4.1.4 删除数据卷</h3>
<p><code>docker volume rm datawhale  #datawhale为卷名</code></p>
<blockquote>
<p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
</blockquote>
<p><strong>清除无用的数据卷</strong></p>
<p><code>docker volume prune</code></p>
<h2 id="4-2-挂载主机目录">4.2 挂载主机目录</h2>
<h3 id="4-2-1-挂载主机目录作为数据卷">4.2.1 挂载主机目录作为数据卷</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ www]# docker run -d --name web2 --mount type=bind,source=/www,target=/usr/share/nginx/html nginx</span><br><span class="line">d7ee4773a9c6d492b12c7e4a7e9fc87db19ac9582b6b5cfb111ac81e0e0ae6af</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载主机的www文件夹到容器的/usr/share/nginx/html目录。本地主机目录必须是绝对路径且必须存在，否则会报错</span></span><br></pre></td></tr></table></figure>
<p>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p>
<h3 id="4-2-2-挂载主机单个文件作为数据卷">4.2.2 挂载主机单个文件作为数据卷</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ /]# docker run -d --name web3 --mount type=bind,source=/.test,target=/root/.test centos</span><br><span class="line">37a0e2129636ff67b446048cdde2964b507c4fb6393630eba380ad6fd64b2dda</span><br></pre></td></tr></table></figure>
<h1>5. Docker网络</h1>
<h2 id="5-1-基础网络介绍">5.1 基础网络介绍</h2>
<h3 id="5-1-1-外部访问容器">5.1.1 外部访问容器</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/9453987.html">Docker容器内部端口映射到外部宿主机端口 - 运维笔记</a></p>
<p>一篇很不错的docker端口映射的笔记</p>
</blockquote>
<p>3.3节<code>docker run</code>命令中提到过，<code>-p, -P</code>可以指定端口映射。<code>-P</code>随机指定，<code>-p</code>特指某端口。</p>
<h4 id="映射所有接口地址">映射所有接口地址</h4>
<p>使用<code>hostPort:containerPort</code>格式本地的 80 端口映射到容器的 80 端口</p>
<p><code>docker run -d -p 80:80 nginx</code></p>
<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h4 id="映射到指定地址的指定端口">映射到指定地址的指定端口</h4>
<p>使用<code>ip:hostPort:containerPort</code>格式</p>
<p>比如<code>docker run -d -p 127.0.0.1:80:80 nginx</code></p>
<h4 id="映射到指定地址的任意端口">映射到指定地址的任意端口</h4>
<p>使用<code>ip::containerPort</code>绑定<code>localhost</code>的任意端口到容器的80端口，本地主机会自动分配一个端口。</p>
<p><code>docker run -d -p 127.0.0.0::80 nginx</code></p>
<p>可以使用<code>udp</code>来指定<code>udp</code>端口</p>
<p><code>docker run -d -p 127.0.0.1:80:80/udp nginx</code></p>
<h4 id="查看映射端口配置">查看映射端口配置</h4>
<p><code>docker port 容器id 端口</code>查看已绑定的地址</p>
<h3 id="5-1-2-容器互联">5.1.2 容器互联</h3>
<h4 id="新建网络">新建网络</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker network create -d bridge mynet</span><br><span class="line">ce82c22db3246994b9f902d418ebb81b81bfe80f4299243f4b9b520a28835d2d</span><br><span class="line"></span><br><span class="line">-d 指定docker网络类型</span><br></pre></td></tr></table></figure>
<h4 id="连接容器">连接容器</h4>
<p>运行一个容器并连接到新建的<code>mynet</code>网络</p>
<p><code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code></p>
<p>再开一个终端，再运行一个容器并加入到<code>mynet</code>网络</p>
<p><code>$ docker run -it --rm --name busybox2 --network my-net busybox sh</code></p>
<p>再开一个终端查看容器信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span></span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             &quot;sh&quot;                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             &quot;sh&quot;                16 minutes ago      Up 16 minutes                           busybox1</span><br></pre></td></tr></table></figure>
<p>在第一个容器中<code>ping</code>第二个容器，来证明互联</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping busybox2</span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</span><br></pre></td></tr></table></figure>
<p>用<code>ping</code>来测试连接<code>busybox2</code>容器，它会解析成 172.19.0.3。</p>
<h3 id="5-1-3-配置DNS">5.1.3 配置DNS</h3>
<p><code>Docker</code>利用虚拟文件来挂载容器的 3个相关配置文件，来自定义配置容器的主机名和DNS。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@c896492cf579 /]# mount</span><br><span class="line">overlay on / type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/SSEB54NI6MD56XYER3WGEIVCO7:/var/lib/docker/overlay2/l/AVOXTTPYDQARCCBYY6GIVC7NMZ,upperdir=/var/lib/docker/overlay2/be32cb0ee2b3f1c91a9d2906812f704c261ae8bc1e82d25784f72a012b30fdab/diff,workdir=/var/lib/docker/overlay2/be32cb0ee2b3f1c91a9d2906812f704c261ae8bc1e82d25784f72a012b30fdab/work)</span><br><span class="line">proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on /dev type tmpfs (rw,nosuid,size=65536k,mode=755)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>这种机制可以让宿主主机 DNS 信息发生更新后，所有<code>Docker</code>容器的 DNS 配置通过 <code>/etc/resolv.conf</code>文件立刻得到更新。</p>
<p>配置全部容器的 DNS ，也可以在主机的 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;114.114.114.114&quot;,</span><br><span class="line">    &quot;8.8.8.8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和8.8.8.8。使用以下命令来证明其已经生效。</p>
<blockquote>
<p>设置完一定要重启才能生效</p>
<p><strong>重启docker服务</strong>  systemctl restart  docker</p>
</blockquote>
<h2 id="5-2-Docker的网络模式">5.2 Docker的网络模式</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker network ls  # 查看网络</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">e78c44b9ed15   bridge    bridge    local</span><br><span class="line">12fdc8dfd506   host      host      local</span><br><span class="line">ce82c22db324   mynet     bridge    local</span><br><span class="line">e5b08a153008   none      null      local</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>网络模式</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bridge</td>
<td>为每一个容器分配、设置 IP 等，并将容器连接到一个 <code>docker0</code> 虚拟网桥，默认为该模式。</td>
</tr>
<tr>
<td>Host</td>
<td>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</td>
</tr>
<tr>
<td>None</td>
<td>容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP 等。</td>
</tr>
<tr>
<td>Container</td>
<td>新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</td>
</tr>
</tbody>
</table>
<h3 id="Bridge模式">Bridge模式</h3>
<p>当<code>Docker</code>进程启动时，会在主机上创建一个名为<code>docker0</code>的虚拟网桥，此主机上启动的<code>Docker</code>容器会连接到这个虚拟网桥上，附加在其上的任何网卡之间都能自动转发数据包。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。从<code>docker0</code>子网中分配一个 IP 给容器使用，并设置 <code>docker0 </code>的 IP 地址为容器的默认网关。在主机上创建一对虚拟网卡<code>veth pair</code>设备，<code>Docker </code>将 <code>veth pair</code> 设备的一端放在新创建的容器中，并命名为<code>eth0</code>（容器的网卡），另一端放在主机中，以<code>vethxxx</code>这样类似的名字命名，并将这个网络设备加入到 <code>docker0</code> 网桥中。可以通过<code>brctl show</code>命令查看。</p>
<p>运行一个基于<code>busybox</code>镜像构建的容器<code>bbox01</code>，查看<code>ip addr</code></p>
<blockquote>
<p>busybox 被称为嵌入式 Linux 的瑞士军刀，整合了很多小的 unix 下的通用功能到一个小的可执行文件中。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker run -it --name bbox01 busybox</span><br><span class="line">/ # ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">107: eth0@if108: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到eth0</span></span><br></pre></td></tr></table></figure>
<p>宿主机执行<code>ip addr</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:16:3e:00:37:72 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.152.19/20 brd 172.17.159.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 293187274sec preferred_lft 293187274sec</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:74:be:3a:4e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">84: br-ce82c22db324: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    link/ether 02:42:d6:d6:e5:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.19.0.1/16 brd 172.19.255.255 scope global br-ce82c22db324</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">108: vethc7d10d1@if107: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link/ether ce:d4:31:fa:13:bd brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"><span class="meta"> #</span><span class="bash">可以看到vethc7d...</span></span><br></pre></td></tr></table></figure>
<p>所以说守护进程会创建一对对等的虚拟设备接口<code>veth pair</code>，将容器的接口设置为<code>eth0</code>接口（容器的网卡），另一个接口放置在宿主机的命名空间，以类似 <code>vethxxx</code> 这样的名字命名。</p>
<p>同时，守护进程还会从网桥 <code>docker0</code> 的私有地址空间中分配一个 IP 地址和子网给该容器，并设置 docker0 的 IP 地址为容器的默认网关。也可以安装 <code>yum install -y bridge-utils</code> 以后，通过 <code>brctl show</code> 命令查看网桥信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br-ce82c22db324         8000.0242d6d6e5d5       no</span><br><span class="line">docker0         8000.024274be3a4e       no              vethc0e3def</span><br></pre></td></tr></table></figure>
<p>对于每个容器的 IP 地址和 Gateway 信息，可以通过 <code>docker inspect 容器名称|ID</code> 进行查看，在 <code>NetworkSettings</code> 节点中可以看到详细信息。</p>
<p>可以通过 <code>docker network inspect bridge</code> 查看所有 <code>bridge</code> 网络模式下的容器，在 <code>Containers</code> 节点中可以看到容器名称。</p>
<blockquote>
<p>关于 <code>bridge</code> 网络模式的使用，只需要在创建容器时通过参数 <code>--net bridge</code> 或者 <code>--network bridge</code> 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/04/19/byEhgoLHf3iVzvR.png" alt="image-20210419093917459"></p>
<h3 id="Host模式">Host模式</h3>
<ul>
<li>host 网络模式需要在创建容器时通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定；</li>
<li>采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；</li>
<li>host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。</li>
</ul>
<p><img src="https://i.loli.net/2021/04/19/cAtKkHpF7QeJS9N.png" alt="image-20210419101703706"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker run -it --name bbox02 --net host busybox</span><br><span class="line">/ # ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast qlen 1000</span><br><span class="line">    link/ether 00:16:3e:00:37:72 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.152.19/20 brd 172.17.159.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 293183500sec preferred_lft 293183500sec</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:74:be:3a:4e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">84: br-ce82c22db324: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:d6:d6:e5:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.19.0.1/16 brd 172.19.255.255 scope global br-ce82c22db324</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:16:3e:00:37:72 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.152.19/20 brd 172.17.159.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 293183473sec preferred_lft 293183473sec</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    link/ether 02:42:74:be:3a:4e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">84: br-ce82c22db324: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    link/ether 02:42:d6:d6:e5:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.19.0.1/16 brd 172.19.255.255 scope global br-ce82c22db324</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>可以看到容器与宿主机的br-ce82c22db324一模一样。</p>
<blockquote>
<p>如果启动容器的时候使用<code>host</code>模式，那么这个容器将不会获得一个独立的<code>Network Namespace</code>，而是和宿主机共用一个<code>Network Namespace</code>。容器将不会虚拟出自己的网卡，配置自己的<code>IP</code>等，而是使用宿主机的<code>IP</code>和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
</blockquote>
<h3 id="None模式">None模式</h3>
<ul>
<li>none 网络模式是指禁用网络功能，只有 lo 接口 local 的简写，代表 127.0.0.1，即 localhost 本地环回接口。在创建容器时通过参数 <code>--net none</code> 或者 <code>--network none</code> 指定；</li>
<li>none 网络模式即不为 Docker Container 创建任何的网络环境，容器内部就只能使用 loopback 网络设备，不会再有其他的网络资源。可以说 none 模式为 Docke Container 做了极少的网络设定，但是俗话说得好“少即是多”，在没有网络配置的情况下，作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了 Docker 设计理念的开放。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# docker run -it --name bbox03 --net none busybox</span><br><span class="line">/ # ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>docker network inspect none</code> 查看所有 <code>none</code> 网络模式下的容器。</p>
<blockquote>
<p>使用<code>none</code>模式，<code>Docker</code> 容器拥有自己的 <code>Network Namespace</code>，但是，并不为<code>Docker</code> 容器进行任何网络配置。也就是说，这个 <code>Docker</code> 容器没有网卡、IP、路由等信息。需要自己为 <code>Docker</code> 容器添加网卡、配置 IP 等</p>
</blockquote>
<h3 id="Container模式">Container模式</h3>
<ul>
<li>Container 网络模式是 Docker 中一种较为特别的网络的模式。在创建容器时通过参数 <code>--net container:已运行的容器名称|ID</code> 或者 <code>--network container:已运行的容器名称|ID</code> 指定；</li>
<li><strong>处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/04/19/nBwDvyd7uQipLzC.png" alt="image-20210419102659865"></p>
<p><strong>Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等</strong>。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。</p>
<blockquote>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个<code>Network Namespace</code>，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的<code>IP</code>，而是和一个指定的容器共享<code>IP</code>、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p>
</blockquote>
<h2 id="5-3-高级网络配置">5.3 高级网络配置</h2>
<h3 id="5-3-1-相关命令">5.3.1 相关命令</h3>
<p>Docker网络相关命令。</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code>定制 <code>docker0</code> 的掩码</li>
<li><code>-H SOCKET...</code> 或 <code>--host=SOCKET... Docker</code> 服务端接收命令的通道</li>
<li><code>--icc=true|false</code> 是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li>
<li><code>--iptables=true|false</code> 是否允许 Docker 添加 <code>iptables</code> 规则</li>
<li><code>--mtu=BYTES</code> 容器网络中的 <code>MTU</code></li>
</ul>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li>
</ul>
<p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li>
<li><code>-p SPEC</code> 或 --publish=SPEC` 映射容器端口到宿主主机</li>
<li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li>
</ul>
<h3 id="5-3-2-容器访问控制">5.3.2 容器访问控制</h3>
<p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。</p>
<h4 id="容器访问外部网络">容器访问外部网络</h4>
<p>需要本地系统的转发支持。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查转发是否打开</span></span><br><span class="line">(base) [root@iZ2ze2m65fn6to8rcr3rjaZ ~]# sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1  # 已打开</span><br></pre></td></tr></table></figure>
<p>手动打开</p>
<p><code>sysctl -w net.ipv4.ip_forward=1</code></p>
<blockquote>
<p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p>
</blockquote>
<h4 id="容器之间访问">容器之间访问</h4>
<p>需要两方面的支持</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li>
<li>本地系统的防火墙软件 <code>-- iptables</code> 是否允许通过。</li>
</ul>
<h4 id="访问所有端口">访问所有端口</h4>
<p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p>
<p>可见，<strong>默认情况下，不同容器之间是允许网络互通的</strong>。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>&#123;&quot;icc&quot;: false&#125;</code> 来禁止它。</p>
<h4 id="访问指定端口">访问指定端口</h4>
<p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p>
<p>此时，系统中的 <code>iptables</code> 规则可能是类似</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo iptables -nL</span></span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-端口映射实现">5.3.3 端口映射实现</h3>
<p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h4 id="容器访问外部实现">容器访问外部实现</h4>
<p>容器所有到外部网络的连接，源地址都会被 NAT （网络地址转换协议）成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo iptables -t nat -nL</span></span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中，上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h4 id="外部访问容器实现">外部访问容器实现</h4>
<p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p>
<h3 id="5-3-4-配置docker0网桥">5.3.4 配置docker0网桥</h3>
<p>Docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 <code>docker0</code> 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<ul>
<li><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5/24</li>
<li><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</li>
</ul>
<p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.3a1d7362b4ee       no              veth65f9</span><br><span class="line">                                             vethdda6</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p>
</blockquote>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p>
<h3 id="5-3-5-自定义网桥">5.3.5 自定义网桥</h3>
<p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> dev docker0 down</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl delbr docker0</span></span><br></pre></td></tr></table></figure>
<p>创建一个网桥 <code>bridge0</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo brctl addbr bridge0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip addr add 192.168.5.1/24 dev bridge0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> dev bridge0 up</span></span><br></pre></td></tr></table></figure>
<p>查看确认网桥创建并启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ip addr show bridge0</span></span><br><span class="line">4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span><br><span class="line">    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.5.1/24 scope global bridge0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bridge&quot;: &quot;bridge0&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p>
<p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p>
<h1>6. Docker Compose</h1>
<h2 id="6-1-Docker-Compose简介">6.1 Docker Compose简介</h2>
<p>我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知</p>
<p><strong>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</strong></p>
<h2 id="6-2-如何使用Docker-Compose">6.2 如何使用Docker Compose</h2>
<p>在<code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p>按照教程运行compose项目之后，Linux命令行不能直接访问网站，可以使用wget间接访问。</p>
<ul>
<li><code>wget -help</code>查看是否有<code>wget</code>；</li>
<li>Centos安装wget<code>yum -y install wget</code>；</li>
<li>Ubuntu安装wget <code>apt-get update; apt-get install wget</code>；</li>
<li>执行<code>wget http://localhost:5000</code>，会将网页下载到本地<code>index.html</code>文件中，可用vim打开查看网页。</li>
<li>执行<code>wget http://localhost:5000</code>一次，就相当于刷新了一次页面。</li>
</ul>
<h2 id="6-3-Docker-Compose基本使用">6.3 Docker Compose基本使用</h2>
<h3 id="6-3-1-启动服务">6.3.1 启动服务</h3>
<blockquote>
<p>在docker compose中，我们习惯把每一个容器叫做service。</p>
</blockquote>
<p>在创建好<code>docker-compose.yml</code>文件后，可以通过命令<code>docker-compose up</code>将文件中定义的容器都启动起来。</p>
<p>命令自动连接默认文件<code>docker-compose.yml</code>，也可给文件起其他名字，这样在使用时需要指定文件名。</p>
<p><code>docker-compose up -f docer-test.yml</code></p>
<p>但是直接通过这种方式的话会直接将启动时的输出打印到终端，所以我们常会加上<code>-d</code>参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-查看服务状态">6.3.2 查看服务状态</h3>
<p>查看一下创建的service状态：<code>docker-compose ps</code></p>
<p>查看所有service的状态：<code>docker-compose ps -a</code></p>
<h3 id="6-3-3-停止或删除服务">6.3.3 停止或删除服务</h3>
<p><code>docker-compose stop</code>;</p>
<p><code>docker-compose down</code>;</p>
<blockquote>
<p>stop时直接停止services，down时停止并删除创建的service,volume和network</p>
</blockquote>
<h3 id="6-3-4-进入服务">6.3.4 进入服务</h3>
<p><code>docker-compose exec mysql bash</code></p>
<p>exec后面接的就是我们要进入具体的service的名字，名字后面就是我们要执行的命令。</p>
<h3 id="6-3-5-查看服务输出日志">6.3.5 查看服务输出日志</h3>
<p><code>docker-compose logs</code></p>
<h2 id="6-4-Compose模板文件">6.4 Compose模板文件</h2>
<p>见<a target="_blank" rel="noopener" href="https://github.com/datawhalechina/team-learning-program/blob/master/Docker/05%20Docker%20Compose.md#compose%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6">Compose模板文件</a>.</p>
<h1>7. 综合实践</h1>
<h2 id="7-1-挂载部署">7.1 挂载部署</h2>
<p>这种方式类似于常规部署，通过数据卷的方式将宿主机的jar包挂载到容器中，然后执行jar包的jdk选择容器中的而非采用本地的。</p>
<ul>
<li>将jar包上传到服务器的指定目录，比如/root/docker/jar</li>
<li>通过<code>docker pull openjdk:8</code>获取镜像</li>
<li>编写docker-compose.yml文件</li>
<li>执行命令<code>docker-compose up -d</code>启动jar包，可以通过docker ps查看容器是否在运行，需要注意的是默认查看所有运行中的容器。</li>
<li>如果容器启动失败或者状态异常，可以通过docker logs查看日志</li>
<li>通过docker inspect myopenjdk查看容器详细信息，可以看到容器ip已经设置成功</li>
<li>在虚拟机中打开浏览器输入jar包项目的访问地址，就可以看到运行的项目，需要注意访问端口是映射过的端口而非项目实际端口</li>
</ul>
<h2 id="7-2-构建镜像部署">7.2 构建镜像部署</h2>
<ul>
<li>将jar包上传到服务器的指定目录，比如/root/docker/jar。</li>
<li>在该目录下创建Dockerfile文件，通过vim等编辑工具在Dockerfile中编辑内容</li>
<li>Dockerfile构建完成以后可以通过命令docker build构建镜像，然后再运行容器，这里咱们用docker-compose命令直接编排构建镜像和运行容器。</li>
<li>编写docker-compose.yml文件</li>
<li>执行docker-compose up –d直接启动基于文件构建的自定义镜像，如果镜像不存在会自动构建，如果已存在那么直接启动。如果想重新构建镜像，则执行docker-compose build。如果想在执行compose文件的时候重构，则执行docker-compose up –d –build。</li>
<li>在浏览器中输入访问路径可以看到项目已经正常运行</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1059482037@qq.com">萧瑟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoucz97.gitee.io/2021/04/12/docker%E7%AC%94%E8%AE%B0/">https://zhoucz97.gitee.io/2021/04/12/docker%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoucz97.gitee.io" target="_blank">雪落山庄</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="https://zhoucz97.gitee.io/image-bed/WallpaperCollection/705446.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://i.loli.net/2021/02/08/WImOlpfcH3Qqn4X.png" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/02/08/WImOlpfcH3Qqn4X.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.loli.net/2021/02/08/bEwC6NitH3l5gry.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/02/08/bEwC6NitH3l5gry.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/19/2021-4-19%E5%B0%8F%E8%AE%B0/"><img class="prev-cover" src="https://zhoucz97.gitee.io/image-bed/WallpaperCollection/234750-158921207008d8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2021-4-19小记</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/24/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><img class="next-cover" src="https://zhoucz97.gitee.io/image-bed/WallpaperCollection/background7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">动态规划之01背包问题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">1. Docker概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Docker%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%EF%BC%9F"><span class="toc-text">1.1 Docker为什么出现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Docker%E5%8E%86%E5%8F%B2"><span class="toc-text">1.2 Docker历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">1.3 Docker与虚拟机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">2. Docker安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-text">2.1 Docker的基本组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-Docker%E9%95%9C%E5%83%8F"><span class="toc-text">2.1.1 Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8"><span class="toc-text">分层存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-Docker%E5%AE%B9%E5%99%A8"><span class="toc-text">2.1.2 Docker容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-Docker%E4%BB%93%E5%BA%93"><span class="toc-text">2.1.3 Docker仓库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AE%89%E8%A3%85Docker"><span class="toc-text">2.2 安装Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-text">2.3 阿里云镜像加速</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%9B%9E%E9%A1%BEhello-world%E6%B5%81%E7%A8%8B"><span class="toc-text">2.4 回顾hello-world流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">2.5 底层原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">3. Docker常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="toc-text">3.1 帮助命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">3.2 镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%8E%B7%E5%8F%96-%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-text">3.2.1 获取&#x2F;下载镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F"><span class="toc-text">3.2.2 列出镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-text">3.2.3 删除镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F"><span class="toc-text">3.2.4 搜索镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-text">3.2.5 Dockerfile构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FROM%E6%8C%87%E5%AE%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="toc-text">FROM指定基础镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RUN%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">RUN执行命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-text">构建镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Context%EF%BC%89"><span class="toc-text">镜像构建上下文（Context）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">3.3 容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.1 新建并启动容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.2 启动已终止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.3 停止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.4 重启容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-5-%E5%88%97%E5%87%BA%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.5 列出运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-6-%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.6 进入容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#attach%E5%91%BD%E4%BB%A4"><span class="toc-text">attach命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec%E5%91%BD%E4%BB%A4"><span class="toc-text">exec命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-7-%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.7 退出容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-8-%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.8 删除容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-9-%E6%9A%82%E5%81%9C%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.9 暂停容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-10-%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3.10 导出容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-11-%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8%E5%BF%AB%E7%85%A7"><span class="toc-text">3.3.11 导入容器快照</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%B8%B8%E7%94%A8%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-text">3.4 常用其他命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.5 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">4. Docker数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">4.1 数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">4.1.1 创建数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">4.1.2 查看数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">4.1.3 启动一个挂载数据卷的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">4.1.4 删除数据卷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95"><span class="toc-text">4.2 挂载主机目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">4.2.1 挂载主机目录作为数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">4.2.2 挂载主机单个文件作为数据卷</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">5. Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.1 基础网络介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8"><span class="toc-text">5.1.1 外部访问容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80"><span class="toc-text">映射所有接口地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="toc-text">映射到指定地址的指定端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%BB%E6%84%8F%E7%AB%AF%E5%8F%A3"><span class="toc-text">映射到指定地址的任意端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">查看映射端口配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="toc-text">5.1.2 容器互联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">新建网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8"><span class="toc-text">连接容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E9%85%8D%E7%BD%AEDNS"><span class="toc-text">5.1.3 配置DNS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.2 Docker的网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bridge%E6%A8%A1%E5%BC%8F"><span class="toc-text">Bridge模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Host%E6%A8%A1%E5%BC%8F"><span class="toc-text">Host模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#None%E6%A8%A1%E5%BC%8F"><span class="toc-text">None模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Container%E6%A8%A1%E5%BC%8F"><span class="toc-text">Container模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-text">5.3 高级网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">5.3.1 相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">5.3.2 容器访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C"><span class="toc-text">容器访问外部网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BF%E9%97%AE"><span class="toc-text">容器之间访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%AB%AF%E5%8F%A3"><span class="toc-text">访问所有端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="toc-text">访问指定端口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.3.3 端口映射实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">容器访问外部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">外部访问容器实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E9%85%8D%E7%BD%AEdocker0%E7%BD%91%E6%A1%A5"><span class="toc-text">5.3.4 配置docker0网桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%A1%A5"><span class="toc-text">5.3.5 自定义网桥</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">6. Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Docker-Compose%E7%AE%80%E4%BB%8B"><span class="toc-text">6.1 Docker Compose简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker-Compose"><span class="toc-text">6.2 如何使用Docker Compose</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-Docker-Compose%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">6.3 Docker Compose基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="toc-text">6.3.1 启动服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-text">6.3.2 查看服务状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E5%81%9C%E6%AD%A2%E6%88%96%E5%88%A0%E9%99%A4%E6%9C%8D%E5%8A%A1"><span class="toc-text">6.3.3 停止或删除服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-4-%E8%BF%9B%E5%85%A5%E6%9C%8D%E5%8A%A1"><span class="toc-text">6.3.4 进入服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-5-%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97"><span class="toc-text">6.3.5 查看服务输出日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-Compose%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6"><span class="toc-text">6.4 Compose模板文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">7. 综合实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%8C%82%E8%BD%BD%E9%83%A8%E7%BD%B2"><span class="toc-text">7.1 挂载部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2"><span class="toc-text">7.2 构建镜像部署</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgb(176,196,222)"><div id="footer-wrap"><div class="copyright">&copy;2021 By 萧瑟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'fB1TCwaFGyuGBoL5Q8c8WVLO-gzGzoHsz',
      appKey: 'xLd1VgPUex34iDpH11EDz1Qm',
      placeholder: '记得留下您的昵称和邮箱，方便得到回复哦~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="仁,义,礼,智,信,温,良,恭,俭,让" data-fontsize="18px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>