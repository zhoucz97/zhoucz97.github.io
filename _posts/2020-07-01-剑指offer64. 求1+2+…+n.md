---
layout: post
title: 剑指offer64. 求1+2+…+n
date: 2020-07-01 
categories: Leetcode
tags: 递归
---

> [原题地址](https://leetcode-cn.com/problems/qiu-12n-lcof/) 

![](/images/posts/2020/07/10.png)

### 方法一  递归
递归的话是很容易想到的，但是在判断递归终止条件的时候，需要用到判断语句，不符合题意。所以我们就要考虑，有什么东西能够代替判断语句呢？我们知道&&有一个性质就是 **短路运算** ，举例`A && B`，如果A为`false`，那么就不会再去判断B，同理||也是一样的,`A || B`，当A为`true`时，程序不会再去判断B，我们可以用这个性质来代替判断语句，写出如下代码。
**代码一 &&**
```
int sumNums(int n) {
    n && (n += sumNums(n-1));
    return n;
}
```

**代码二 ||**
```
int sumNums(int n) {
    !n || (n += sumNums(n-1));
    return n;
}
```

*时间复杂度O(n)*
*空间复杂度O(n)*

### 方法二  快速乘
考虑 A 和 B 两数相乘的时候我们如何利用加法和位运算来模拟，其实就是将 B 二进制展开，如果 B 的二进制表示下第 i 位为 1，那么这一位对最后结果的贡献就是 `A*(1<<i)` ，即 `A<<i`。我们遍历B二进制展开下的每一位，将所有贡献累加起来就是最后的答案，这个方法也被称作「俄罗斯农民乘法」，经常被用于两数相乘取模的场景，如果两数相乘已经超过数据范围，但取模后不会超过，我们就可以利用这个方法来拆位取模计算贡献，保证每次运算都在数据范围内。

**代码一**
```
int quickMulti(int A, int B) {
    int ans = 0;
    for ( ; B; B >>= 1) {
        if (B & 1) 
            ans += A;
        A <<= 1;
    }
    return ans;
}
```

回到本题，求和公式为`n * (n+1) / 2`，  `/2`可以用 `<<1` 来完成，而 `n*(n+1)` 就用快速乘来完成

**代码二**
```
int sumNums(int n) {
    int a = n, b = n+1, ans = 0;
    for(; b; b >>= 1){
        if(b & 1)
            ans += a;
        a <<= 1;    
    }
    return ans>>1;
}
```
但是题目要求不能有循环，所以还要想办法去除循环，我们根据题意了解到 `1 <= n <= 10000`， 所以n展开成二进制不会超过14位，我们手动展开14层就好啦。就好啦。就好啦。就。。好。。啦。。。。。。
emmm，这是官方题解给的，我刚看到的时候，一脸懵逼。

**代码三**
```
int sumNums(int n) {
    int ans = 0, A = n, B = n + 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    return ans >> 1;
}
``` 