---
layout: post
title: 3.无重复字符的最长子串
date: 2020-07-01 
categories: Leetcode
tags: 滑动窗口
---

# [3.无重复字符的最长子串  难度:中等](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) 

![image](/images/posts/2020/07/070101.jpg)

## 思路
如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第k个字符作为起始位置，并且得到了不包含重复字符的最长子串，结束位置为 r_k 。那么当我们选择第k+1个字符作为起始位置时，首先从k+1到r_k的字符显然是不重复的，并且由于少了原本的第k个字符，我们可以尝试继续增大 r_k ，直到右侧出现了重复字符为止。

所以可以用滑动窗口来解决，左指针代表起始位置，右指针代表结束位置。在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

用哈希表来判断是否有重复的字符，哈希表中存储目前为止的子串。

```
int lengthOfLongestSubstring(string s) {
    unordered_set<char> occ;   //哈希表，记录每个字符是否出现过
    int n = s.size();
    int r = 0, ans = 0;
    occ.insert(s[0]);
    for(int l=0; l<n; l++) {
        // 只要不重复，就不断移动右指针
        while(r+1 < n && !occ.count(s[r+1])) {
            occ.insert(s[r+1]);
            r++;
        }
        ans = max(ans, r-l+1);
        //每次处理完以l为起始的子串后，移除最左字符，进行下一次处理
        occ.erase(s[l]);
    }
    return ans;
}
```