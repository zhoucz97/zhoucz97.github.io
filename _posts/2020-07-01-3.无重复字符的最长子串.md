---
layout: post
title: 3.无重复字符的最长子串
date: 2020-07-01 
categories: Leetcode
tags: 滑动窗口 哈希表
---

> [原题地址](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) 

![](/images/posts/2020/07/01.jpg)

## 思路
1. **设左右指针，左指针代表起始位置，右指针代表结束位置，来维持一个窗口，即滑动窗口；**
2. 对于每个起始位置，我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；
3. 而保证这两个指针对应的子串无重复字符的任务，交给哈希表来完成；
4. 不断将起始位置右移，便得到了答案。

## 例子
nums = [a,b,c,a,b,c,b,b]
l代表左指针，r代表右指针
- 初始时左右指针都在第一个位置
![](/images/posts/2020/07/02.png)
- 起始位置不动，右指针移动，借助哈希表，当指向第三个元素c时，右指针移动停止，此时该起始位置最大长度为3
![](/images/posts/2020/07/03.png)
- 得到了第一个起始位置的最大长度，记下，左指针右移
![](/images/posts/2020/07/04.png)
- 右指针移动，得到了第二个起始位置对应的最大长度为3
![](/images/posts/2020/07/05.png)
- 不断重复上述过程，遍历完毕即可得到答案。

## 代码
```
int lengthOfLongestSubstring(string s) {
    unordered_set<char> occ;   //哈希表，记录每个字符是否出现过
    int n = s.size();
    int r = 0, ans = 0;
    occ.insert(s[0]);
    for(int l=0; l<n; l++) {
        // 只要不重复，就不断移动右指针
        while(r+1 < n && !occ.count(s[r+1])) {
            occ.insert(s[r+1]);
            r++;
        }
        ans = max(ans, r-l+1);
        //每次处理完以l为起始的子串后，移除最左字符，进行下一次处理
        occ.erase(s[l]);
    }
    return ans;
}
```