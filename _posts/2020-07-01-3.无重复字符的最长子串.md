---
layout: post
title: 3.无重复字符的最长子串
date: 2020-07-01 
categories: Leetcode
tags: 滑动窗口 哈希表
---

> [原题地址](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) 

![](/images/posts/2020/07/01.jpg)

## 思路1
1. **设左右指针，左指针代表起始位置，右指针代表结束位置，来维持一个窗口，即滑动窗口；**
2. 对于每个起始位置，我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；
3. 而保证这两个指针对应的子串无重复字符的任务，交给哈希表来完成；
4. 不断将起始位置右移，便得到了答案。

### 例子
nums = [a,b,c,a,b,c,b,b]
l代表左指针，r代表右指针
- 初始时左右指针都在第一个位置
![](/images/posts/2020/07/02.png)
- 起始位置不动，右指针移动，借助哈希表，当指向第三个元素c时，右指针移动停止，此时该起始位置最大长度为3
![](/images/posts/2020/07/03.png)
- 得到了第一个起始位置的最大长度，记下，左指针右移
![](/images/posts/2020/07/04.png)
- 右指针移动，得到了第二个起始位置对应的最大长度为3
![](/images/posts/2020/07/05.png)
- 不断重复上述过程，遍历完毕即可得到答案。

### 代码
#### cpp
```cpp
int lengthOfLongestSubstring(string s) {
    unordered_set<char> occ;   //哈希表，记录每个字符是否出现过
    int n = s.size();
    int r = 0, ans = 0;
    occ.insert(s[0]);
    for(int l=0; l<n; l++) {
        // 只要不重复，就不断移动右指针
        while(r+1 < n && !occ.count(s[r+1])) {
            occ.insert(s[r+1]);
            r++;
        }
        ans = max(ans, r-l+1);
        //每次处理完以l为起始的子串后，移除最左字符，进行下一次处理
        occ.erase(s[l]);
    }
    return ans;
}
```

#### python
```python
def lengthOfLongestSubstring(self, s: str) -> int:
    r = 0  # 右指针
    rel = 0
    s_len = len(s)  # 字符串长度
    if s_len == 0:
        return 0
    hash = {}   # 哈希表  存元素
    hash[s[0]] = 1
    
    for l in range(s_len): # 左指针
        # 右移右指针
        while r + 1 < s_len and s[r+1] not in hash:
            hash[s[r+1]] = 1
            r += 1
        # 到数组边界或者遇到重复的了
        rel = max(rel, r-l+1)
        del(hash[s[l]])
    return rel
```

## 思路2

和思路1基本一致，但是不再是把数组中每一个元素都当做左指针，来得到最大值，而是借助了KMP的思想。

**在这里哈希表存的不再只是元素，而是元素和他在字符串中的位置**

举个例子就能明白。思路1里的例子在这里不太明显，我们换一个明显就懂的例子。如下：

- 经过几步右指针走到如下位置：
![](/images/posts/2020/07/1601.png)

- 再走一步，这时哈希表中存储了a,b,c前三个元素以及它们的位置，所以检测到了b元素重复。按照思路1，这时可以让左指针左移1位。**我们现在也让左指针左移，但不是左移一位，而是左移到重复元素的位置之后，也就是第三个元素c的位置。**
![](/images/posts/2020/07/1602.png)
![](/images/posts/2020/07/1603.png)

这时候你可能有疑问，那这么做，会不会丢失一些可能性呢，比如说以第2个元素b开头的最长无重复子串，根本就没有考虑进来。

**答案是，不用考虑进来。因为以第一个元素a为开头的最长无重复子串是`abc`，这时又遇到了元素b，那么开头元素在`[a, 重复元素]`，也就是`[a, b]`这个区间中，最长的子串肯定是以a开头的，所以以b开头直接不用考虑。**

如果还不明白，可以举个极端一点的例子。  
假设有数组`[a, b, c, d, e, f, e, e]`。

我们开始会得到子串`a, b, c, d, e, f`，然后遇到了重复元素e,那么你手动模拟一下，以`b, c, d, e`这些元素开头的子串，是不是都比以a开头的子串短。事实上，以a开头的子串是`a,b,c,d,e,f`，以b开头的是`b,c,d,e,f`，以c开头的是`c,d,e,f`......是越来越短的。

***这种思路是数据结构上的KMP子串匹配算法***

### python代码如下
```python
def lengthOfLongestSubstring(self, s: str) -> int:
    r = 0  # 右指针
    l = 0
    rel = 0
    s_len = len(s)  # 字符串长度
    # 这里我们不存储下标，而是存储下标+1，一方面是避开0，另一方面会方便后面的计算
    hash = {}   # 哈希表  存元素和其下标+1
    while l < s_len: # 左指针
        # 右移右指针
        while r < s_len and s[r] not in hash:
            hash[s[r]] = r+1
            r += 1
        rel = max(rel, r-l)
        # 1.到数组边界，直接结束
        if r >= s_len:  break
        # 2.遇到重复的了，进行处理, 现在r指向重复的元素
        else:
            # 注意哈希表中存的是下标+1，不是下标，所以直接得到new_l
            new_l = hash[s[r]] 
            for i in range(l, new_l):
                del(hash[s[i]])
            l = new_l
    return rel
```

