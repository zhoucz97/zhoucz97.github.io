---
layout: post
title: 524. Longest Word in Dictionary through Deleting
date: 2020-07-29
categories: Leetcode
tags: 双指针
---


> [原题地址](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/) 

![](/images/posts/2020/07/2901.png)

## 方法一 双指针

我们可以通过双指针算法来判断一个串是否能由s串删除某些元素得到。

拿第一个例子来说明： `s="abpcplea", d[0]="ale"`

1. 定义双指针p,q，分别指向s,d[0]，计数器count
2. 开始遍历：
    - 如果匹配成功，比如`s[0] == d[0][0]`，则`p++,q++,count++`
    - 如果匹配不成功，则`p++`
3. 如果最后`count==len(d[0])`，说明全部匹配成功。

### 子串匹配代码

```python
def inStr(i):
    p = q = count = 0  # 双指针，计数器
    slen, dlen = len(s), len(d[i]) # s串和子串的长度
    while p < slen and q < dlen:
        if s[p] == d[i][q]:  # 匹配成功一个字符
            count += 1
            q += 1
        p += 1  
    if count == dlen:
        return True
    return False
```

有了上面的代码，问题就很简单了，每次调用`inStr()`函数来判断是否为s的"子串"，再更新当前记录的结果。

### Python代码
```python
def findLongestWord(self, s: str, d: List[str]) -> str:
    def inStr(i):   # 判断子串函数
        p = q = count = 0
        slen, dlen = len(s), len(d[i])
        while p < slen and q < dlen:
            if s[p] == d[i][q]:
                count += 1
                q += 1
            p += 1
        if count == dlen:
            return True
        return False

    rel = ''
    for i in range(len(d)):
        if inStr(i) and len(d[i]) >= len(rel):
            # 如果该串更长  或者  长度和rel一样但是字典序更靠前，    则更新
            if len(d[i]) > len(rel) or (len(d[i]) == len(rel) and d[i] < rel):
                rel = d[i]
    
    return rel
```

### 时间复杂度O(mn)

两层循环，外层长度为`len(d)`，记为`m`，内层长度最长为`max(len(s),len(d[i]))`，记为`n`，`m<n`，所以时间复杂度为`O(mn)`

### 空间复杂度O(x)

这里的s表示结果串`rel`的长度
