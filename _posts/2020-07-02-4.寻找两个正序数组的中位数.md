---
layout: post
title: 4.寻找两个正序数组的中位数
date: 2020-07-02 
categories: Leetcode
tags: 二分法
---

> [原题地址](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/) 
> [官方题解](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/) 

此题我感觉巨难... 

---

![](/images/posts/2020/07/0203.png)

## 思路

此题如果不要求时间复杂度O(log(m+n))的话，是非常简单的，可以合并数组后排序找中位数，时间复杂度为O((m+n)log(m+n))，也可以用双指针遍历找中位数，时间复杂度为O(m+n)，但都不符合题意。看到O(log(m+n))，应该想到二分法。

**采用二分查找思想来设置分割线**

一个**有序数组**的中位数可以把一个数组分为两部分，我们以中位数为界，设置一条分割线。若数组长度为偶数则平均分配，若数组长度为奇数则规定把中位数分到左侧（分到右侧也可以，但后续代码要改变），比如数组`[1,2,3,4,5]`（分割线在3,4之间），数组`[1,2,3,4]`（分割线在2,3之间）
我们可以把这种思想扩展到两个数组中。因为两个数组都是有序的，所以如果把两个数组合并成一个有序数组的话，就可以轻松找到分割线。但现在是两个数组，那我们怎么做呢？

**我们可以只盯着第一个数组来找分割线，然后第二个数组的分割线位置由某种条件自动产生**。

举个例子，如图所示。
![](/images/posts/2020/07/0204.png)

两个数组一共有10个元素，中位数是(8+9)/2，我们用二分法来对第一个数组划分分割线，第一个数组分割线左侧有两个元素，只有第二个数组分割线左侧有三个元素，才能满足左右两侧数量一致。所以知道数组1数组2的长度，就知道左侧需要共5个元素，又知道数组1左侧有2个元素，那么数组2左侧就有5-2=3个元素。这就是数组2的分割线位置能够自动产生的原因。

所以我们来总结一下上段文字。
*假定数组1有m个元素，数组2有n个元素。如果`m+n`为奇数，则左侧需要 `(m+n+1) / 2` 个元素，如果`m+n`为偶数，则左侧需要`(m+n) / 2` 个元素，因为int类型的除法性质，所以可以统一写成 **`totalLeft = (m+n+1) / 2`**, 其中totalLeft为分割线左侧元素个数。我们再假定数组1右侧第一个元素下标为 i, 也就是数组1左侧共有 i 个元素，假定数组2右侧第一个元素下标为 j, 则  **`j = totalLeft - i`**，这个公式也就是我们上文说的自动产生，即主要关注i就行了，j可以由公式直接得出。*

![](/images/posts/2020/07/0205.png)

**总而言之，我们要确定一条红线，使得红线左侧元素个数等于右侧元素个数（两数组总元素数为偶数），或者红线左侧元素个数比右侧多一个（两数组总元素数为奇数）。**

但是还要注意一点，看下图：
![](/images/posts/2020/07/0206.png)

分割线左侧的所有元素不一定都小于等于右侧，比如图中的8和6，所以这里要用二分法，不断移动i，（j也会跟着移动），使得分割线左侧所有元素都小于等于右侧所有元素。换种说法，使得交叉小于等于关系成立。而交叉关系可以表示为：

**`nums1[i - 1] <= nums2[j]  &&  nums2[j - 1] <= nums1[i]`**

所以该公式的否定为`nums1[i - 1] > nums2[j] ||  nums2[j - 1] > nums1[i]`，我们可以二者取其一作为二分查找的判断条件（这里我也不太明白，但是weiwei大佬说二分减治（排除）的思想就是把不对的排除掉，剩下的就是正确的。  所以二者选其一作为条件即可，另一个条件不用管。

所以我们的思路为：

**使用二分法找到i位置，使分割线把两个数组分成两部分，并且满足：**

1. **红线左侧的元素数量等于右侧的元素数量或者左侧元素数量比右侧多一个**
2. **红线左侧所有元素都小于等于右侧所有元素，即交叉小于等于关系成立**

**那么我们可以得出，最后的中位数只与分割线左右两侧紧挨的元素有关**

![](/images/posts/2020/07/0207.png)

还有一个特殊情况需要注意，看下图：

![](/images/posts/2020/07/0208.png)

由于我们只调整第一个数组红线的位置，使得第二个数组的红线位置自动产生，只有第一个数组长度小于第二个数组，才能保证第二个数组的分割线两侧一定有元素，不会出现数组越界的情况。所以如果第一个数组长度比第二个长，我们可以先把两个数组交换。还有，如果出现图中左图的情况，则中位数只与数组1红线左侧元素以及数组2红线两侧元素有关。同理如果出现图中右图的情况，则中位数只与数组1红线右侧元素以及数组2红线两侧元素有关。

### 代码
```
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int m = nums1.size(), n = nums2.size();
    //若第一个数组比第二个数组长，则交换。是我们上面提到过的特殊情况
    if(m > n){
        swap(nums1, nums2);
        swap(m, n);
    }
    //分割线左侧的总元素个数totalLeft
    int totalLeft = (m+n+1) / 2;
    //二分法的左右指针，作用于第一个数组
    int left = 0, right = m;
    while(left < right) {
        //第一个数组右侧第一个元素的位置
        int i = (left + right + 1) / 2;
        //第二个数组右侧第一个元素的位置
        int j = totalLeft - i;
        //二分，如果不满足交叉关系，则取数组1的左半部分
        if(nums1[i-1] > nums2[j])
            right = i-1;
        //满足交叉关系，则取数组1的右半部分
        else
            left = i;
    }

    int i = left, j = totalLeft - i;
    // 当i=0时，说明第一个数组分割线左边没有值，为了不影响 nums1[i - 1] <= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax)的判断，所以将它设置为int的最小值
    int nums1LeftMax = (i==0 ? INT_MIN : nums1[i-1]);
    // 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响
    // nums2[j - 1] <= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin)
    // 的判断，所以将它设置为int的最大值
    int nums1RightMin = (i==m ? INT_MAX : nums1[i]);
    //同理
    int nums2LeftMax = (j==0 ? INT_MIN : nums2[j-1]);
    int nums2RightMin = (j==n ? INT_MAX : nums2[j]);
    //若两数组总长为奇数，则中位数一定是左侧最大值（因为左侧比右侧多一个数）
    if((m+n) % 2 == 1)
        return max(nums1LeftMax, nums2LeftMax);
    //若两数组总长为偶数，则中位数一定是四个数中的中间两个数取平均    
    else
        return 1.0 * (max(nums1LeftMax, nums2LeftMax)+min(nums1RightMin, nums2RightMin)) / 2;
}
```

**时间复杂度**：因为我们只对数组1做二分查找，而数组1长度一定小于数组2，所以为O(log(min(m,n)))

**空间复杂度**：O(1)

