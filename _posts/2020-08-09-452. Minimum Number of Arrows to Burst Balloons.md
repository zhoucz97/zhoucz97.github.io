---
layout: post
title: 452. Minimum Number of Arrows to Burst Balloons
date: 2020-08-09
categories: Leetcode
tags: 贪心
---

> [原题地址](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/) 

![](/images/posts/2020/08/0901.png)


这题干也挺长的，但是说了个啥意思呢，我们给它扒拉扒拉，让它原形毕露。

如图

天空中飘着这么多五颜六色的气球，它们的y轴坐标忽略不计，只给出了x轴的起始坐标和结束坐标。现在我要在x轴沿着y轴方向射箭，问最少射出几根箭才能将气球全部扎破。
![](/images/posts/2020/08/0902.png)

我们再抽象一下

**问题变成了：穿过所有区间，至少需要几根线？**
![](/images/posts/2020/08/0903.png)

这样的话题目的特性就很明显了，自然而然就想到了排序和贪心。

如果按照结束位置从小到大排序，那么问题就很简单了。

我们将一个气球用箭穿过的时候，从哪里穿才能使得这支箭多穿几个气球呢？

因为是按照结束位置从小到大排序的，所以**从一个气球的结束位置穿过，能够保证在穿过本个气球的情况下，能够最多的穿后面的气球。**

### Python代码
```python
def findMinArrowShots(self, points: List[List[int]]) -> int:
    n = len(points)
    if n < 2:  # 特判
        return n
    points = sorted(points, key=lambda x: x[1])
    # count计数， arrow记录当前这根箭的坐标，初始化为第一个气球的结束位置
    count, arrow = 1, points[0][1]
    for i in range(1, n):
        # 如果这根箭能够穿过这个气球
        if points[i][0] <= arrow and points[i][1] >= arrow:
                continue
        # 如果这根箭不能穿过这个气球，那么拿一根新的箭
        else:
            arrow = points[i][1]
            count += 1
    return count
```


### 时间复杂度O(nlogn)

排序算法使用时间O(nlogn)

### 空间复杂度O(1)


