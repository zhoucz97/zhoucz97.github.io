---
layout: post
title: 974.和可被 K 整除的子数组
date: 2020-07-10 
categories: Leetcode
tags: 哈希表
---

> [原题地址](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/) 

![](/images/posts/2020/07/1002.png)

#### **本题核心知识点：  前缀和+哈希表+同余定理+排列组合+负数求余**

#### 负数求余  
C++的负数求余，结果还是负数，比如 -3 % 5 = -3，所以我么不能写A[i]%K，而应该写成(A[i]%K+K)%K，防止出现负数

### 思路   
令`P[i] = A[0]+A[1]+......+A[i]`，那么每个连续子数组的和`sum(i,j)`都可以表示为`P[j]-P[i-1]`的形式。此时，判断子数组的和能否被 K 整除就等价于判断`（P[j]-P[i-1]）mod K == 0`，根据同余定理，只要`P[j]mod K == P[i-1] mod K`，就可以保证上面的等式成立。  

但是有一个问题，如果要求第0项的前缀和呢？按照公式应该求`(P[0]-P[-1])mod K`并且`P[-1]=0`，但是数组下标是从0开始的，**所以我们假定`P[-1]=0`（实际并不存在），目的就是为了能够让公式适用于所有情况**。至此，我们可以将公式写成如下形式以使公式万能：
***`sum(i, j) = P[j] - P[i-1], (0 <= i <= j <= n 且 P[-1] = 0)`***

所以我们对数组遍历并在原数组上求出以i为结尾的前缀和，维护一个哈希表hash，键为前缀和对K的余数，值为该余数出现的次数。在初始化hash表时，要加入元素{0: 1}，代表着`P[-1] = 0`
遍历hash表，根据同余定理，只要值>=2，就说明该键符合同余定理，也就说明这几个前缀和的余数相等，根据排列组合，n个数中挑出两个共有`n*(n-1)/2`种。

### 代码
```cpp
int subarraysDivByK(vector<int>& A, int K) {
    unordered_map<int, int> hash;
    int len = A.size();
    int modulus;    //余数
    for(int i=0; i<len; i++){
        if(i!=0)    A[i] += A[i-1];  //前缀和
        modulus = (A[i] % K + K) % K;   //保证永远是正数
        hash[modulus]++;
    }
    int rel = 0;
    for(auto [key, value] : hash){
        rel += value*(value-1)/2;   //排列组合
    }
    return rel;
}
```
