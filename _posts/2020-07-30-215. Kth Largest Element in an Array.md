---
layout: post
title: 215. Kth Largest Element in an Array
date: 2020-07-30
categories: Leetcode
tags: 排序
---

> [原题地址](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) 

![](/images/posts/2020/07/3005.png)


## 方法一  堆排序

此题其实用一个库函数sort就可以解决，但这显然不是本题的目的，所以我们要自己写一个算法来解决。

要找第k个大的元素，我们首先想到的就是堆排序。

正好我写过一个堆排序的文章，里面有详细的解释和代码
[堆排序算法详解（附代码）](https://zhoucz97.github.io/2020/07/%E5%A0%86%E6%8E%92%E5%BA%8F/)

将堆排序的代码直接拿过来用就可以了。

### Python代码

```python
def findKthLargest(self, nums: List[int], k: int) -> int:
    def headAdjust(k, l):
        i = 2 * k + 1  # i为k的左子结点
        temp = nums[k]  # 暂存子树根结点
        while i < l:
            if i+1 < l and nums[i+1] > nums[i]:  # 让i指向k的左右结点中大的那个
                i += 1
            if temp >= nums[i]: # 如果k的两个子节点都比k小
                break
            else:
                nums[k] = nums[i]
                k = i
            i = 2*i + 1  # 指向被调整过的那棵子树
        nums[k] = temp
    def buildMaxHeap(l):  # 建立大顶堆
        for i in range(l//2-1, -1, -1):
            headAdjust(i, l)
    l = len(nums)
    buildMaxHeap(l)  # 建堆
    for i in range(0, k-1):
        nums[0], nums[l-i-1] = nums[l-i-1], nums[0] # 输出大顶堆中最大元素
        headAdjust(0, l-i-1)  # 调整堆
    return nums[0]
```

### 时间复杂度O(nlogn)

### 空间复杂度O(logn)

`buildMaxHeap`的循环里调用`headAdjust()`算法时间复杂度为`O(logn)`，而`headAdjust()`里面使用了常数项变量`temp`，所以空间复杂度为`O(logn)`