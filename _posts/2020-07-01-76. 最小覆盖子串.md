---
layout: post
title: 76.最小覆盖子串
date: 2020-07-01 
categories: Leetcode
tags: 滑动窗口 哈希表
---

> [原题地址](https://leetcode-cn.com/problems/minimum-window-substring/) 

![](/images/posts/2020/07/06.png)

## 思路
**题目注意事项**
- T串中可能会有重复字符，比如"ABA"；T串长度可能比S串小；T串S串都有可能是空串。

我们可以用滑动窗口的思想解决这个问题，在滑动窗口类型的问题中都会有两个指针。一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。

当窗口中不包含子串时，r右移；当窗口中包含子串时，检查此时串的长度，并且l右移。

**怎么判断当前窗口是否包含子串呢？** c++中可以用ordered_map，即哈希表来记录字符和它们出现的个数，再用一个哈希表动态维护窗口中的字符和它们出现的个数。当窗口哈希表包含T中的所有字符并且个数都不小于t中字符的个数，那么当前窗口就包含子串。

## 代码
### 代码一
```
class Solution {
public:
    //两个哈希表，存储串中字符以及它们的个数
    unordered_map<char, int> sFreq, tFreq;
    //检查当前窗口是否包含串t
    bool check(){
        for(auto p : tFreq){
            if(sFreq[p.first] < p.second)
                return false;
        }
        return true;
    }
    string minWindow(string s, string t) {
        int len = s.size();
        for(auto i : t){
            tFreq[i]++;
        }
        int left = 0, right = 0;  //定义左右指针
        //暂存答案串的首尾位置和长度
        int ansl, ansr, max_len = INT_MAX;
        sFreq[s[right]]++;
        while(left <= right && right < len){
            //当前窗口包含串t
            if(check()) {
                if(right - left + 1 < max_len){
                    ansl = left;
                    ansr = right;
                    max_len = right-left+1;
                }
                sFreq[s[left]]--;
                left++;
            }
            //当前窗口不包含串t
            else{
                right++;
                if(right < len)
                    sFreq[s[right]]++;
            }     
        }
        return max_len==INT_MAX ? "" : s.substr(ansl, max_len);
    }
};
```

### 代码二
*上述代码当前窗口包含t时，left++，此处可以循环检查，若包含则一直left++，所以while中的代码可以改成：* 
```
while(left <= right && right < len){
    //当前窗口包含串t
    while(check()) {
        if(right - left + 1 < max_len){
            ansl = left;
            ansr = right;
            max_len = right-left+1;
        }
        sFreq[s[left]]--;
        left++;
    }
    //当前窗口不包含串t
    right++;
    if(right < str.size())
        sFreq[str[right]]++;
}
```

### 时间复杂度
最坏情况下左右指针对 s 的每个元素各遍历一遍，哈希表中对 s 中的每个元素各插入、删除一次，对 t 中的元素各插入一次。每次检查是否可行会遍历整个 t 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 C，则渐进时间复杂度为 O(C*|s| + |t|)。
### 空间复杂度
这里用了两张哈希表作为辅助空间，每张哈希表最多不会存放超过字符集大小的键值对，我们设字符集大小为 C ，则渐进空间复杂度为 O(C)。

### 代码三
*对于串t"ABC"来说，模式串S中不是ABC的元素是无用的，因此可以先进行预处理，扔掉那些t中没有出现过的字符。*

```
class Solution {
public:
    //两个哈希表，存储串中字符以及它们的个数
    unordered_map<char, int> sFreq, tFreq;
    //检查当前窗口是否包含串t
    bool check(){
        for(auto p : tFreq){
            if(sFreq[p.first] < p.second)
                return false;
        }
        return true;
    }
    string minWindow(string s, string t) {
        int len = s.size();
        //存储预处理后的s串中元素和其对应的下标
        vector<char> str;
        vector<int> str_index;
        for(int i = 0; i < len; i++){
            if(find(t.begin(), t.end(), s[i]) != t.end()){
                str.push_back(s[i]);
                str_index.push_back(i);
            }
        }
        if(str.empty()) return "";
        for(auto i : t)
            tFreq[i]++;
        int left = 0, right = 0;  //定义左右指针
        //暂存答案串的首尾位置和长度
        int ansl, ansr, max_len = INT_MAX;
        sFreq[str[right]]++;
        while(left <= right && right < str.size()){
            //当前窗口包含串t
            while(check()) {
                if(str_index[right] - str_index[left] + 1 < max_len){
                    ansl = str_index[left];
                    ansr = str_index[right];
                    max_len = ansr-ansl+1;
                }
                sFreq[str[left]]--;
                left++;
            }
            right++;
            if(right < str.size())
                sFreq[str[right]]++;     
        }
        return max_len==INT_MAX ? "" : s.substr(ansl, max_len);
    }
};
```