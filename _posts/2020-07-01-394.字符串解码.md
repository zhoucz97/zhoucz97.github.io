---
layout: post
title: 394.字符串解码
date: 2020-07-01 
categories: Leetcode
tags: 递归
---

> [原题地址](https://leetcode-cn.com/problems/minimum-window-substring/) 

![](/images/posts/2020/07/08.png)

## 思路
**可以用编译原理中巴斯范式的思想**
根据题目的定义，我们可以推导出这样的巴科斯范式（BNF）：
![](/images/posts/2020/07/09.png)
- Digit 表示十进制数位，可能的取值是 0 到 9 之间的整数
- Alpha 表示字母，可能的取值是大小写字母的集合，共 52 个
- Digit 表示一个整数，它的组成是Digit 出现一次或多次
- String 代表一个代解析的字符串，它可能有三种构成，如 BNF 所示
- ϵ 表示空串，即没有任何子字符

| | Alpha | Digits | ϵ
---|---|---|---
String | String -> Alpha String | String -> Digits[String]String | String -> ϵ

可见不含多重定义的项，为 **LL(1) 文法** ，即：
  1. 从左向右分析（Left-to-right-parse）
  2. 最左推导（Leftmost-derivation）
  3. 超前查看一个符号（1-symbol lookahead）
  4. 它决定了我们从左向右遍历这个字符串，每次只判断当前最左边的一个字符的分析方法是正确的。

## 代码
### 当成LL（1）来看待，一个分析表，一个输入串，一个栈
```
class Solution {
public:
    string src;    //输入串
    int ptr;       //输入串的指针
    //将连续的几个digit字符转化为数字
    int getDigit(){
        int rel = 0;
        while(isdigit(src[ptr])){
            rel = rel * 10 + (src[ptr++] - '0');
        }
        return rel;
    }
    //递归函数
    string getString(){
        //递归边界
        if(ptr == src.size() || src[ptr] == ']')
            return "";
        
        int repTime;    //当前数字，也就是重复次数
        string ret = "";    //当前[]内的字符串
        //如果是   string ->  digit[string]string 形式，处理string->digit[string]
        if(isdigit(src[ptr])){
            //求出倍数
            repTime = getDigit();
            //过滤掉左括号
            ++ptr;
            string temp = getString();
            //过滤掉右括号
            ++ptr;
            while(repTime--)    ret += temp;
        }
        //如果是  string ->  alpha string形式，处理string -> alpha
        else if(isalpha(src[ptr])){
            ret += src[ptr++];
        }
        //  +getString()统一处理最后的string
        return ret + getString();
    }

    string decodeString(string s) {
        src = s;
        ptr = 0;
        return getString();
    }
};
```
