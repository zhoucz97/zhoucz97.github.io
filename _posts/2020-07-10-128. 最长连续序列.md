---
layout: post
title: 128.最长连续序列
date: 2020-07-10 
categories: Leetcode
tags: 哈希表 并查集
---

> [原题地址](https://leetcode-cn.com/problems/longest-consecutive-sequence/) 

![](/images/posts/2020/07/1003.png)

# 方法一 哈希表
### 思路  
我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1, x+2,⋯是否存在，假设最长匹配到了x+y，那么以 x 为起点的最长连续序列即为 x, x+1, x+2,⋯,x+y，其长度为y+1，我们不断枚举并更新答案即可。 

对于匹配的过程，暴力的方法是O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至O(1) 的时间复杂度。  

仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举O(n)个数，内层需要暴力匹配O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x, x+1, x+2,⋯,x+y 的连续序列，而我们却重新从x+1，x+2x+2 或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举x为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。  

那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在x−1 即能判断是否需要跳过了。

###代码
```cpp
int longestConsecutive(vector<int>& nums) {
    unordered_set<int> uset;
    for(auto num : nums)
        uset.insert(num);
    int longstr = 0;
    for(auto n : uset){
        if(!uset.count(n-1)){
            int currentstr = 0, t = n;
            while(uset.count(t)){
                t++;
                currentstr++;
            }
            longstr = max(longstr, currentstr);
        }
    }
    return longstr;
}
```

# 方法二 并查集
**初始化的时候先把数组里每个元素初始化为他的下一个数；
并的时候找他能到达的最远的数字就可以了。**

[并查集详解](https://blog.csdn.net/qq_41593380/article/details/81146850)

### 代码
```cpp
class Solution {
public:
    unordered_map<int, int> a;
    int find(int x){
        return a.count(x) ? find(a[x]) : x;
    }
    int longestConsecutive(vector<int>& nums) {
        for(auto num : nums)
            a[num] = num + 1;
        int rel = 0;
        for(auto num : nums){
            int y = find(num+1);
            rel = max(rel, y - num);
        }
        return rel;
    }
};
```

但是这样的代码时间超过限制，所以要对并查集进行路径优化，也就是把树的高度降下来，所以代码中第五行改为：

`return a.count(x) ? a[x] = find(a[x]) : x;`

意思就是找到某元素的祖先后，把祖先设置成这个元素的父亲

![](/images/posts/2020/07/1004.png)