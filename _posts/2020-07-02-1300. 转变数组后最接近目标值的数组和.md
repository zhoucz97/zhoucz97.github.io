---
layout: post
title: 1300.转变数组后最接近目标值的数组和
date: 2020-07-02 
categories: Leetcode
tags: 二分法
---

> [原题地址](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/) 

![](/images/posts/2020/07/0209.png)
![](/images/posts/2020/07/0210.png)

### 思路
这道题使用的是*二分法*来查找value，所以我们首先要确定value的范围，value的上界非常好确定，就是arr数组中的最大值，为什么这么说呢？因为当value取值比arr最大值还大时，按题目要求计算的和永远都是arr的和，而题目要求如果有多种方案，返回value最小的那一个，也就是arr中的最大值。所以**value的上界为arr中的最大值**。

**value的下界，我们可以直接取1**，为什么呢？因为`target>=1`，所以取一个最小的正数就行了。但是这个下界，是不够精确的。
value的下界还可以继续优化。先给结论，**下界为`min(arr中的最小值, target / arr.size() )`**

其实是很好理解的。如果arr中最小值比`target/arr.size()`小，那么下界就是arr中最小值。反之，`[1, target/arr.size()]`这个区间内，肯定`value=target/arr.size()`是最优的。所以比`target/arr.size()`还小的那些值，直接不用考虑了。

确定了value的上下界，直接进行二分查找就可以了。

### 代码
```
int findBestValue(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    // differ为当前和与target的差值的绝对值    n为最后要返回的结果
    int len = arr.size(), differ = INT_MAX, n = arr[len-1];
    int left = min(target / len, arr[0]), right = arr[len-1];
    while(left <= right){
        int mid = (left + right) / 2;
        int sum = 0;
        for(auto a : arr){
            if(a <= mid)    sum += a;
            else    sum += mid;
        }
        int t = (abs(sum - target));
        if((t == differ && mid < n) || (t < differ)){
            differ = t;
            n = mid;
        }
        if(sum > target)   right = mid - 1;
        else    left = mid + 1; 
    }
    return n;
}
```

**时间复杂度**：O(nlogn)
**空间复杂度**：O(logn)   排序用到的
