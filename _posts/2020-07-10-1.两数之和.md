---
layout: post
title: 1.两数之和
date: 2020-07-10 
categories: Leetcode
tags: 哈希表
---

> [原题地址](https://leetcode-cn.com/problems/two-sum/) 

![](/images/posts/2020/07/1001.png)

这题没什么好说的，直接暴力或者哈希表存储

## c++版本
```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> hash;
    for(int i=0; i<nums.size(); i++){
        int compent = target - nums[i];
        if(hash[compent]){
            int j;
            for(j = 0; j<nums.size(); j++){
                if(i == j)  continue;
                if(nums[j] == compent)
                    break;
            }
            return {i, j};
        }
        else
            hash[nums[i]]++;
    }
    return {};
}
```


## python3版本

### 方法一  

**解题关键主要是想找到 num2 = target - num1，是否也在 list 中**，那么就需要运用以下两个方法：

- `num2 in nums`，返回 True 说明有戏 
- `nums.index(num2)`，查找 num2 的索引

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    for num in nums:
        if target - num in nums:
            # nums.count(num)  计算num在列表中出现了几次
            if target - num == num and nums.count(num) == 1:
                continue
            else:
                x1 = nums.index(num)
                # nums.index(num, i)  从nums数组的第i个元素开始查找
                x2 = nums.index(target - num, x1 + 1)
                return [x1, x2]
```

### 方法二

**解题思路是在方法一的基础上，优化解法。想着，num2 的查找并不需要每次从 nums 查找一遍，只需要从 num1 位置之后查找即可。**

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    for i in range(len(nums)):
        if target - nums[i] in nums[i+1 : ]:
            return [i, nums.index(target-nums[i], i+1)]
```

### 方法三

**用字典模拟哈希表，并用方法二类似的思路，遍历nums列表，每次判断字典中有无target - num，并把当前元素和索引加入字典**

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    hashmap = {}
    for i, num in enumerate(nums):
        if target - num in hashmap:
            return [hashmap[target - num] ,i]
        hashmap[num] = i
```