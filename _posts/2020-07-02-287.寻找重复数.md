---
layout: post
title: 287.寻找重复数
date: 2020-07-02 
categories: Leetcode
tags: 二分法
---

> [原题地址](https://leetcode-cn.com/problems/find-the-duplicate-number/) 

![](/images/posts/2020/07/0202.png)

## 方法一：

***二分法+[抽屉原理](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fr=aladdin)***

### 思路
以 `[1, 2, 2, 3, 4, 5, 6, 7]` 为例，一共 8 个数，`n + 1 = 8`，`n = 7`，根据题目意思，每个数都在 1 和 7 之间。

例如：区间 `[1, 7]` 的中位数是 4，遍历整个数组，统计小于等于 4 的整数的个数，至多应该为 4 个。换句话说，整个数组里小于等于 4 的整数的个数如果严格大于 4 个，就说明重复的数存在于区间 `[1, 4]`，它的反面是：重复的数存在于区间 `[5, 7]`。

于是，二分法的思路是先猜一个数（有效范围 `[left, right]`里的中间数 mid），然后统计原始数组中小于等于这个中间数的元素的个数 cnt，如果 cnt 严格大于 mid，（注意我加了着重号的部分“小于等于”、“严格大于”）依然根据抽屉原理，重复元素就应该在区间 `[left, mid]` 里。

### 代码
```
int findDuplicate(vector<int>& nums) {
        int len = nums.size();
        int low = 1, high = len - 1;
        while(low < high) {
            int mid = low + (high-low) / 2;
            int cnt = 0;
            for(auto num : nums){
                if(num <= mid)
                    cnt++;
            }
            if(cnt > mid)
                high = mid;
            else
                low = mid+1;
        }
        return low;
    }
```

**时间复杂度**：O(NlogN)，二分法的时间复杂度为 O(log N)，在二分法的内部，执行了一次 for 循环，时间复杂度为 O(N)，故时间复杂度为 O(N log N)。
**空间复杂度**：O(1)，使用了一个 cnt 变量，因此空间复杂度为 O(1)。

