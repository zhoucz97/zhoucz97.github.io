---
layout: post
title: 53.最大子序和
date: 2020-07-02
categories: Leetcode
tags: 动态规划
---

> [原题地址](https://leetcode-cn.com/problems/maximum-subarray/) 

![](/images/posts/2020/07/0201.png)

### 思路
*假设数组长为n，用f(i)代表以第i个数结尾的[连续子数组的最大和]，那么我们要求的是 `max{f(i)}`*

以数组`[-2,1,-3,4,-1,2,1,-5,4]`为例:`f(1) = -2`, `f(2) = 1`, `f(3) = -2`。

思路如下：`f(1) = 1`;求`f(2)`的时候，由于`f(1)<0`，所以以第二个元素结尾的最大子序和就是第二个元素自身；求f(3)时，由于`f(2)>0`，所以以第三个元素结尾的最大子序和就是`f(2)+nums[3]`。

所以结论就是：**以第i个元素结尾的最大子序和，要么是以第i-1个元素结尾的最大子序和+nums[i]，要么就是nums[i]本身。**

动态规划转移方程：  ***f(i) = max { f(i-1) + nums[i],  nums[i] };***

### 代码

```
int maxSubArray(vector<int>& nums) {
    if(nums.empty())    return 0;
    vector<int> ans(nums.size());
    ans[0] = nums[0];
    int max_num = nums[0];
    for(int i=1; i<nums.size(); i++) {
        ans[i] = max(ans[i-1]+nums[i], nums[i]);
        max_num = max(max_num, ans[i]);
    }
    return max_num;
}
```

*由于遍历到第i个元素时，前面的元素都弃用，所以可以直接在nums数组上实现ans，这样可以将空间复杂度降低到O(1)，但是破坏了数组。*

```
int maxSubArray(vector<int>& nums) {
    if(nums.empty())    return 0;
    int max_num = nums[0];
    for(int i=1; i<nums.size(); i++) {
        nums[i] = max(nums[i-1] + nums[i], nums[i]);
        max_num = max(max_num, nums[i]);
    }
    return max_num;
}
```